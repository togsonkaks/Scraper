1) Universal size extraction (path + query + srcset + vendor patterns)
// ---- SIZE HINT REGEXES (wide net; vendor-agnostic & vendor-specific) ----
const RX_SRCSET_W   = /\s(\d{2,4})w(?:\s|$)/i;                       // "2000w"
const RX_W_SEG      = /(?:^|\/)[whmwx][_ -]?(\d{2,4})(?=[\/._-]|$)/i;// "/w_375/" "/h-800" "/x1200"
const RX_W_QS       = /[?&](?:im?width|mw|maxw?|w|wid|width)=(\d{2,4})\b/i;
const RX_H_QS       = /[?&](?:h|height)=(\d{2,4})\b/i;
const RX_SIZE_SEG   = /(?:^|\/)Size[_-](\d{3,4})(?=\/|$)/i;          // "/Size_2000/"
const RX_PAIR_X     = /(?:^|[\W_])(\d{3,4})[x×](\d{3,4})(?:[\W_]|$)/i;// "2000x2000" "800×1200"
const RX_AMZ_SX     = /[_-]SX(\d{2,4})[_-]/i;                        // "SX679" (Amazon)
const RX_CLOUDINARY = /\/upload\/[^/]*?w_(\d{2,4})/i;                 // Cloudinary "w_2000"
const RX_IMGIX_QS   = /[?&](?:auto=[^&]*&)?w=(\d{2,4})\b/i;          // imgix
const RX_AEM_IMW    = /[?&](?:imwidth|width)=(\d{2,4})\b/i;          // Adobe AEM
const RX_SHOPIFY    = /_(\d{3,4})x\.\w+\b/i;                          // Shopify "…_2000x.jpg"

// returns { w, h, confidence, reasons:[] }
function estimateSizeFromHints(url, srcsetItem = '') {
  let w = 0, h = 0, conf = 0; const reasons = [];

  const take = (val, bonus, reason) => {
    if (val && val > w) { w = val; conf += bonus; reasons.push(reason + ':' + val); }
  };

  // Highest confidence first
  let m;
  if ((m = url.match(RX_SIZE_SEG)))    take(+m[1], 6, 'Size_####');
  if ((m = srcsetItem.match(RX_SRCSET_W))) take(+m[1], 5, 'srcset ####w');
  if ((m = url.match(RX_PAIR_X)))      { take(+m[1], 5, 'pairX'); h = +m[2]; }
  if ((m = url.match(RX_CLOUDINARY)))  take(+m[1], 4, 'cloudinary w_');
  if ((m = url.match(RX_SHOPIFY)))     take(+m[1], 4, 'shopify _####x');
  if ((m = url.match(RX_W_SEG)))       take(+m[1], 3, 'path w_####/h_####');
  if ((m = url.match(RX_W_QS)))        take(+m[1], 3, 'qs w=');
  if ((m = url.match(RX_IMGIX_QS)))    take(+m[1], 3, 'imgix w=');
  if ((m = url.match(RX_AEM_IMW)))     take(+m[1], 3, 'aem width=');
  if ((m = url.match(RX_AMZ_SX)))      take(+m[1], 2, 'amazon SX####');
  if ((m = url.match(RX_H_QS)))        { h = +m[1]; conf += 1; reasons.push('qs h=' + h); }

  return { w, h, confidence: conf, reasons };
}
This catches both styles you mentioned: /Size_2000/… and /w_2000/…—and many others. 
2) Red-flag small & score with “biggest hint wins” 
const JUNK_HINTS = ['/thumb', '/thumbnail', '/mini', '/sprite', '/logo', '/banner', '/icon', '/swatch', '/color', '/placeholder', '/poster', '/360/', '/video'];

function looksLikeJunk(url){ const u=url.toLowerCase(); return JUNK_HINTS.some(h=>u.includes(h)); }

// score with size hints + demote small + demote junk
function scoreImage(url, idx=999, srcsetItem='') {
  const { w, confidence } = estimateSizeFromHints(url, srcsetItem);
  let score = 50;

  // size bonus/penalty from *any* hint we saw
  if (w >= 2000) score += 40;
  else if (w >= 1600) score += 30;
  else if (w >= 1200) score += 20;
  else if (w >= 800)  score += 10;
  else if (w > 0 && w < 450) score -= 50;     // << red-flag small thumbs

  // double-bonus if we saw the very strong Size_#### path
  if (/\/Size[_-](?:2000|1600|1440|1080)\//i.test(url)) score += 20;

  // vendor "w_####" that’s still big gets some love too
  if (/\/w[_-](?:2000|1600|1440|1200)(?:[\/._-]|$)/i.test(url)) score += 12;

  // junk/UI elements sink
  if (looksLikeJunk(url)) score -= 60;

  // position bias for first few gallery images
  if (idx <= 2) score += 18; else if (idx <= 6) score += 8;

  // confidence tiebreaker
  score += Math.min(confidence, 8);

  return { score, estWidth: w };
}
3) Optional: verify actual pixels for “unknowns”For a handful of top candidates where we didn’t get a clear hint, you can cheaply check naturalWidth/naturalHeight. Cross-origin is fine—you can read naturalWidth without canvas tainting.async function measureActualSize(url, timeoutMs=6000) {
  return new Promise((resolve) => {
    const img = new Image();
    let done = false;
    const kill = setTimeout(() => { if(!done){ done=true; resolve({w:0,h:0}); } }, timeoutMs);
    img.onload = () => { if(!done){ done=true; clearTimeout(kill); resolve({ w: img.naturalWidth, h: img.naturalHeight }); } };
    img.onerror = () => { if(!done){ done=true; clearTimeout(kill); resolve({ w:0, h:0 }); } };
    img.decoding = 'async';
    img.referrerPolicy = 'no-referrer';
    img.src = url;
  });
}

// probe top-K “unknowns” and demote tiny ones
async function verifyUnknowns(cands, K=6, minW=450) {
  const unknowns = cands.filter(c => c.estWidth === 0).slice(0, K);
  const results = await Promise.all(unknowns.map(c => measureActualSize(c.url)));
  unknowns.forEach((c, i) => { c.actual = results[i]; if (c.actual.w && c.actual.w < minW) c.score -= 60; });
}
4) Glue: collect, score, (optionally) verify, return best 
function collectCandidates(root=document){
  const out=[]; let idx=0;
  root.querySelectorAll('picture source[srcset], img[srcset]').forEach(n=>{
    (n.getAttribute('srcset')||'').split(',').map(s=>s.trim()).forEach(item=>{
      const url=(item.split(/\s+/)[0]||'').trim();
      if(/^https?:/i.test(url)) out.push({url, srcset:item, idx:idx++});
    });
  });
  root.querySelectorAll('img[src]').forEach(n=>{
    const url=n.getAttribute('src')||'';
    if(/^https?:/i.test(url)) out.push({url, srcset:'', idx:idx++});
  });
  return out;
}

function canonicalKey(url){
  try{
    const u=new URL(url);
    ['w','width','h','height','fit','auto','q','quality','fm','format'].forEach(p=>u.searchParams.delete(p));
    return `${u.host}${u.pathname}`.replace(/\/Size[_-]\d{3,4}\//ig,'/Size_XXXX/').replace(/\/w[_-]\d{2,4}(?=\/|\.|_|-)/ig,'/w_XX');
  }catch{ return url; }
}

async function pickImagesSmart(root=document, limit=12){
  // collect
  const raw = collectCandidates(root);
  // score
  const scored = raw.map(r=>{
    const {score, estWidth} = scoreImage(r.url, r.idx, r.srcset);
    return { ...r, score, estWidth, key: canonicalKey(r.url) };
  });

  // keep best per canonical key
  const best = new Map();
  for(const c of scored){
    const prev=best.get(c.key);
    if(!prev || c.score>prev.score) best.set(c.key,c);
  }
  const list = Array.from(best.values());

  // verify a few unknowns by actual pixels
  await verifyUnknowns(list.sort((a,b)=>b.score-a.score), 6, 450);

  // final sort (score desc, prefer AVIF/WEBP as tiny tiebreakers)
  const fmt = u => /\.avif\b/i.test(u)?3:/\.webp\b/i.test(u)?2:/\.jpe?g\b/i.test(u)?1:0;
  list.sort((a,b)=> (b.score-a.score) || (fmt(b.url)-fmt(a.url)));

  return list.slice(0,limit).map(x=>x.url);
}

