// ---- imageHelpers.js (or inline in orchestrator) ----
const fetch = require('node-fetch'); // node-fetch@2

const IMG_EXT = /\.(jpe?g|png|webp|avif|gif)(?:\?|#|$)/i;
const BAD_HINTS = /(sprite|logo|icon|badge|placeholder|thumb|swatch|colorway|video|poster|360|spin)/i;

function fromSrcset(srcset = '') {
  // returns the URL with the largest declared width
  let best = null, bestW = -1;
  srcset.split(',').forEach(part => {
    const [u, w] = part.trim().split(/\s+/);
    const m = w && w.match(/(\d+)w/);
    const width = m ? +m[1] : 0;
    if (u && width >= bestW) { bestW = width; best = u; }
  });
  return best || null;
}

function guessWidthFromURL(u) {
  // tries to read 1200/1200x1800/w_1200 patterns
  const m = u.match(/(?:^|[^\d])(\d{3,4})[x_](\d{3,4})|(?:\/|_|=)w[_=]?(\d{3,4})/i);
  if (m) return +(m[1] || m[3] || 0);
  const m2 = u.match(/(\d{3,4})x(\d{3,4})/i);
  if (m2) return +m2[1];
  return 0;
}

function isRejectURL(u) {
  if (!u) return true;
  if (!IMG_EXT.test(u) && !/fm=(?:jpg|jpeg|png|webp|avif)/i.test(u)) return true;
  if (BAD_HINTS.test(u)) return true;
  if (/^data:|\.svg(\?|$)/i.test(u)) return true;
  return false;
}

async function headSize(url, { timeoutMs = 2500 } = {}) {
  const ctl = new AbortController();
  const t = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const r = await fetch(url, { method: 'HEAD', signal: ctl.signal });
    const len = +(r.headers.get('content-length') || 0);
    return Number.isFinite(len) ? len : 0;
  } catch (_) {
    return 0;
  } finally { clearTimeout(t); }
}

// Score = weighted combo so “hero + big + good aspect” floats to top
function scoreCandidate(c) {
  const bytes = c.bytes || 0;
  const width = c.widthGuess || 0;
  const hero = c.isHero ? 1 : 0;
  const aspectScore = (() => {
    const a = c.aspect || 1;
    // prefer 0.7–1.5 for apparel/product
    return a > 0.5 && a < 1.8 ? 1 : 0;
  })();
  // weights: tune if needed
  return hero * 1e9 + bytes * 2 + width * 500 + aspectScore * 1e6;
}

function dedupeByBase(u) {
  try {
    const noQ = u.split('?')[0];
    const base = noQ.substring(noQ.lastIndexOf('/') + 1).toLowerCase();
    // strip transforms
    return base.replace(/-(?:\d{2,4})x(?:\d{2,4})|_?(?:\d{2,4})w/g, '');
  } catch { return u; }
}

function uniqBy(arr, keyFn) {
  const seen = new Set();
  const out = [];
  for (const x of arr) {
    const k = keyFn(x);
    if (!seen.has(k)) { seen.add(k); out.push(x); }
  }
  return out;
}

async function pickBestImages({ document, limit = 12 } = {}) {
  // 1) collect candidates from the live DOM (src + srcset)
  const raw = [];
  document.querySelectorAll('img').forEach(img => {
    let u = img.getAttribute('data-zoom-image') ||
            img.getAttribute('data-full') ||
            img.currentSrc ||
            img.src ||
            fromSrcset(img.getAttribute('srcset'));
    if (!u) return;
    if (isRejectURL(u)) return;

    const widthGuess = guessWidthFromURL(u);
    const aspect = img.naturalWidth && img.naturalHeight
      ? img.naturalWidth / img.naturalHeight
      : undefined;

    const isHero = !!(img.closest('.active,[aria-current="true"],[data-active="true"]'));
    raw.push({ url: u, widthGuess, aspect, isHero });
  });

  // Add JSON-LD + og:image, they’re often the “hero”
  try {
    document.querySelectorAll('script[type="application/ld+json"]').forEach(s => {
      try {
        const j = JSON.parse(s.textContent || '{}');
        const imgs = []
          .concat(j.image || j.images || [])
          .filter(Boolean);
        imgs.forEach(u => {
          if (!isRejectURL(u)) raw.push({ url: u, widthGuess: guessWidthFromURL(u), isHero: true });
        });
      } catch {}
    });
  } catch {}
  const og = document.querySelector('meta[property="og:image"][content]');
  if (og && og.content && !isRejectURL(og.content)) {
    raw.push({ url: og.content, widthGuess: guessWidthFromURL(og.content), isHero: true });
  }

  // 2) de-dup by base filename
  let candidates = uniqBy(raw, r => dedupeByBase(r.url));

  // 3) HEAD fetch in parallel (cap concurrency)
  const pool = [];
  const maxParallel = 8;
  let i = 0;
  const withBytes = [];
  async function runOne(c) {
    c.bytes = await headSize(c.url);
    withBytes.push(c);
  }
  while (i < candidates.length || pool.length) {
    while (i < candidates.length && pool.length < maxParallel) {
      pool.push(runOne(candidates[i++]));
    }
    await Promise.race(pool).catch(()=>{});
    // prune resolved
    for (let j = pool.length - 1; j >= 0; j--) {
      if (pool[j].done) pool.splice(j, 1);
    }
  }

  // 4) score + sort (hero and big first)
  withBytes.forEach(c => c._score = scoreCandidate(c));
  withBytes.sort((a, b) => b._score - a._score);

  // 5) final filter: keep only “real” images (min bytes), output top N
  const MIN_BYTES = 30_000; // tune (reject tiny/LQIP)
  const out = withBytes.filter(c => c.bytes >= MIN_BYTES).slice(0, limit).map(c => c.url);

  return out.length ? out : withBytes.slice(0, limit).map(c => c.url);
}

module.exports = { pickBestImages };
