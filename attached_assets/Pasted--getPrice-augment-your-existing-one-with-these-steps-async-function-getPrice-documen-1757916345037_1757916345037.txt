// ===== getPrice (augment your existing one with these steps) =====
async function getPrice(document, memorySel) {
  // A) Try your existing logic FIRST and validate it.
  let val = null, selUsed = null;
  try {
    // ---- YOUR current extraction here (keep as-is) ----
    // Example:
    // const legacy = ...;
    // if (legacy) { val = legacy.value; selUsed = legacy.selector; }
  } catch {}

  // quick validator
  const good = (n) => isFinite(n) && n > 1 && n < 10000;
  const asNum = (x) => typeof x === 'number' ? x : jsonNum(x);

  // If legacy numeric is good → return immediately
  if (good(asNum(val))) {
    return { value: asNum(val), selector: selUsed || null };
  }

  // B) Strength 1: memory selector → attrs → ancestor block (pick LOWEST)
  const tryPriceFromElement = (sel) => {
    const el = sel ? document.querySelector(sel) : null;
    if (!el) return null;
    const attrN = numberFromAttrs(el);
    if (attrN != null) return { n: attrN, sel, via:'attrs' };
    const blockN = scanAncestorForPrice(el, 3);
    if (blockN != null) return { n: blockN, sel, via:'block' };
    return null;
  };

  let best = null;

  if (memorySel) best = tryPriceFromElement(memorySel);

  // C) Strength 2: common price selectors with the same rule
  if (!best) {
    const sels = [
      '[itemprop="price"]',
      'meta[itemprop="price"]',
      '[data-testid*="price"]',
      '.price,.Price,.product-price,[class*="price"]'
    ];
    for (const s of sels) {
      best = tryPriceFromElement(s);
      if (best) break;
    }
  }

  // D) Strength 3: JSON-LD fallback
  if (!best) {
    const product = findProductNode(getJsonLd(document));
    const n = jsonNum(product?.offers?.price);
    if (n != null) best = { n, sel: 'jsonld:offers.price', via:'jsonld' };
  }

  // E) Choose return
  if (best && good(best.n)) {
    return { value: best.n, selector: best.sel };
  }

  // last resort — even if legacy was bad, return it to avoid empty
  return { value: good(asNum(val)) ? asNum(val) : null, selector: selUsed || null };
}
