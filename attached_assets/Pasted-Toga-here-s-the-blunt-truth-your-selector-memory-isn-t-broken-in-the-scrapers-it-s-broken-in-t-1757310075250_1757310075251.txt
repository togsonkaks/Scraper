Toga, here’s the blunt truth: your selector “memory” isn’t broken in the scrapers — it’s broken in the **Control UI save path**.

# Diagnosis (no fluff)

* You *do* collect the “what did we use?” map inside the product page as `globalThis.__tg_lastSelectorsUsed` (populated by `orchestrator.js`).
* `main.js` correctly fetches that map and hands it back to Control via `scrape-current()` as `selectorsUsed`.
* Control **stores** it in `lastSelectorsUsed` after scraping.
* But when you click **“Save selectors for this host”**, Control **doesn’t use** `lastSelectorsUsed`. It tries to read `window.__tg_lastSelectorsUsed` (which doesn’t exist in the Control window). Result: your save routine thinks it has nothing tracked, falls back to brittle reverse-engineering, and you get the “Failed to find selectors: price, description, images” alert.&#x20;

# Root cause (single line that sinks ships)

In `control.html` save handler you have:

```js
const lastUsed = window.__tg_lastSelectorsUsed || {};
```

This is the wrong window. You should use the variable you already stored from the scrape:

```js
const lastUsed = lastSelectorsUsed || {};
```

Make that one-line swap and your tracked selectors start flowing.&#x20;

# Secondary gotchas (fix these too, or you’ll keep tripping)

1. **Singular vs plural selectors**

* From memory paths you store **`{ selectors: [...] }`** (plural).
* From some generic/custom paths you store **`{ selector: '...' }`** (singular).
* Your save code only checks `.selector`. Add support for both.

2. **Ignore fake placeholders**

* When generic price returns only a string, the orchestrator stamps a placeholder like `"generic-text-selector"`. Do **not** persist that; it’s not a real CSS selector.

# Minimal patch (drop-in)

In `control.html`, inside `saveMemBtn.onclick`, replace the “last used” line and expand the branch that uses tracked selectors:

```diff
-      const lastUsed = window.__tg_lastSelectorsUsed || {};
+      // Use the selectors captured from the last scrape
+      const lastUsed = lastSelectorsUsed || {};
```

And replace the “use tracked selector” block with this resilient version:

```diff
-          if (lastUsed[field] && lastUsed[field].selector) {
-            console.log(`[DEBUG] Using tracked working selector for ${field}:`, lastUsed[field]);
-            result = {
-              selectors: [lastUsed[field].selector],
-              attr: lastUsed[field].attr || 'text',
-              method: lastUsed[field].method || 'tracked'
-            };
-          }
+          if (lastUsed[field]) {
+            const selArr = Array.isArray(lastUsed[field].selectors)
+              ? lastUsed[field].selectors
+              : (lastUsed[field].selector ? [lastUsed[field].selector] : []);
+
+            // Drop placeholders from generic string-only paths
+            const filtered = selArr.filter(s => s && s !== 'generic-text-selector');
+
+            if (filtered.length) {
+              console.log(`[DEBUG] Using tracked working selector(s) for ${field}:`, filtered);
+              result = {
+                selectors: filtered,
+                attr: lastUsed[field].attr || 'text',
+                method: lastUsed[field].method || 'tracked'
+              };
+            }
+          }
```

With those two changes:

* The **checkboxes you saw** (which came from `lastSelectorsUsed`) now actually feed the **save** routine.
* Real selectors (or arrays) flow into `setSelectorMemory`, and they’ll be there next run.
* The bogus `"generic-text-selector"` won’t poison memory.

# Why your Ace Hardware price wasn’t sticking

* The price (`USD539.99`) displays because `getPriceGeneric()` found a value, but it likely returned a **string only**, so the orchestrator recorded a **placeholder** instead of a real CSS path for `price`.
* Because the save handler was reading the wrong global, it never even tried to use the tracked info; then reverse-engineering on a dynamic PDP failed → “Failed to find selectors: price…”.

# Optional hardening (recommended next sprint)

* Update generic collectors (title/price/brand/desc) to **always** return `{ text, selector, attr }` when feasible. That gives you concrete selectors even when not using memory or custom handlers.
* When persisting price selectors, prefer **attribute-based** selectors (e.g., `[itemprop="price"]`, `[data-price]`) over content text to survive price changes.

Ship these patchlets and your selector memory stops gaslighting you. If you want, I’ll audit the generic collectors next and make sure they always emit `{text, selector, attr}` so your memory layer stays robust even without custom handlers.&#x20;
