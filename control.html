<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tagglo Control</title>
  <style>
    body { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; color:#111; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
    input[type="text"] { width: 560px; padding:8px 10px; border:1px solid #ccc; border-radius:6px; }
    button { padding:8px 12px; border:0; border-radius:6px; background:#111; color:#fff; cursor:pointer; }
    button[disabled] { opacity:.5; cursor:not-allowed; }
    #out { white-space: pre; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:8px; margin-top:12px; max-height: 44vh; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .pill { display:inline-block; background:#eee; border-radius:999px; padding:2px 8px; margin-right:6px; font-size:12px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .box { border:1px solid #eee; border-radius:8px; padding:10px; background:#fff; }
    .label { font-weight:700; margin-bottom:4px; }
    .imgs { display:flex; gap:6px; flex-wrap:wrap; }
    .imgs img { height:64px; border-radius:6px; border:1px solid #eee; cursor:pointer; transition:transform 0.2s; }
    .imgs img:hover { transform:scale(1.05); }

    /* Image Overlay Modal */
    .image-overlay { 
      position:fixed; top:0; left:0; width:100%; height:100%; 
      background:rgba(0,0,0,0.9); display:none; z-index:1000; 
      justify-content:center; align-items:center; 
    }
    .image-overlay.show { display:flex; }
    .overlay-content { 
      position:relative; max-width:90%; max-height:90%; 
      display:flex; justify-content:center; align-items:center; 
    }
    .overlay-image { 
      max-width:100%; max-height:100%; object-fit:contain; 
      border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.5); 
    }
    .close-overlay { 
      position:absolute; top:-40px; right:0; background:none; 
      border:none; color:white; font-size:24px; cursor:pointer; 
      padding:8px; border-radius:4px; 
    }
    .close-overlay:hover { background:rgba(255,255,255,0.2); }
    .ai-suggest-btn {
      margin-left: 4px; padding: 2px 6px; font-size: 10px; 
      background: #4CAF50; color: white; border: none; border-radius: 3px; 
      cursor: pointer; vertical-align: middle;
    }
    .ai-suggest-btn:hover { background: #45a049; }
    .ai-suggest-btn:disabled { background: #ccc; cursor: not-allowed; }
    .ai-cache-status {
      margin-left: 12px; padding: 4px 8px; font-size: 11px; border-radius: 4px;
      background: #ffebee; color: #c62828; border: 1px solid #ef9a9a;
    }
    .ai-cache-status.ready {
      background: #e8f5e8; color: #2e7d32; border-color: #81c784;
    }
    .suggestion-panel {
      margin-top: 8px; padding: 8px; background: #e8f5e8; 
      border-radius: 4px; border-left: 4px solid #4CAF50; display: none;
    }
    .suggestion-comparison {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px;
    }
    .suggestion-box {
      padding: 6px; background: white; border-radius: 3px; font-size: 11px;
    }
    .use-suggestion-btn {
      margin-top: 6px; padding: 4px 8px; background: #4CAF50; 
      color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;
    }
    .validation-panel {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      max-width: 80%; max-height: 80%; overflow-y: auto; z-index: 1000; display: none;
    }
    .validation-header {
      padding: 16px; border-bottom: 1px solid #eee; background: #f9f9f9;
      font-weight: bold; display: flex; justify-content: space-between; align-items: center;
    }
    .validation-content {
      padding: 16px; max-height: 60vh; overflow-y: auto;
    }
    .field-card {
      border: 1px solid #eee; border-radius: 6px; margin-bottom: 12px; overflow: hidden;
    }
    .field-header {
      background: #f5f5f5; padding: 8px 12px; font-weight: bold; font-size: 13px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .field-status {
      padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal;
    }
    .field-status.success { background: #e8f5e8; color: #2e7d32; }
    .field-status.failed { background: #ffebee; color: #c62828; }
    .field-body {
      padding: 10px 12px; background: white;
    }
    .field-preview {
      margin-bottom: 8px; font-size: 12px;
    }
    .field-selector {
      font-family: monospace; background: #f8f8f8; padding: 4px 6px; border-radius: 3px;
      font-size: 11px; color: #666; margin-top: 4px;
    }
    .image-urls {
      max-height: 120px; overflow-y: auto; background: #f8f8f8; padding: 6px; border-radius: 3px;
      margin-top: 4px;
    }
    .image-url {
      font-size: 10px; font-family: monospace; color: #666; margin-bottom: 2px; word-break: break-all;
    }
    .validation-footer {
      padding: 12px 16px; border-top: 1px solid #eee; background: #f9f9f9;
      display: flex; gap: 8px; justify-content: flex-end;
    }
  </style>
  <style>
    /* Mobile Preview Styles */
    .device-btn { 
      padding: 6px 12px; border: none; border-radius: 6px; cursor: pointer; 
      font-size: 12px; transition: all 0.2s; margin-right: 8px;
    }
    .device-btn.active { background: #2196F3; color: white; }
    .device-btn:not(.active) { background: #f0f0f0; color: #666; }
    
    .mobile-container {
      border: 1px solid #ddd; border-radius: 0 0 12px 12px; background: #f8f9fa;
      padding: 12px; margin-top: 12px; height: 450px; overflow-y: auto;
      transition: width 0.3s ease; scroll-behavior: smooth;
    }
    .mobile-container.iphone { width: 375px; max-width: 100%; }
    .mobile-container.ipad { width: 768px; max-width: 100%; }
    
    .mobile-content {
      background: white; border-radius: 8px; padding: 12px;
      min-height: 420px; position: relative;
    }
    
    .mobile-grid {
      display: grid; gap: 12px; grid-template-columns: 1fr 1fr;
      grid-auto-rows: masonry; /* Future masonry support */
    }
    .mobile-container.ipad .mobile-grid {
      grid-template-columns: 1fr 1fr 1fr !important;
    }
    
    /* Mobile Image Detail Modal (Pinterest-style) */
    .mobile-image-modal {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: white;
      z-index: 1000;
      display: none;
      flex-direction: column;
    }
    
    .mobile-image-modal.show {
      display: flex;
    }
    
    .mobile-modal-header {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      background: white;
      position: sticky;
      top: 0;
      z-index: 1001;
    }
    
    .mobile-back-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #333;
      padding: 4px 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    
    .mobile-back-btn:hover {
      background: #f0f0f0;
    }
    
    .mobile-header-space {
      flex: 1;
    }
    
    .mobile-save-btn {
      background: #E60023;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .mobile-save-btn:hover {
      background: #c8001e;
    }
    
    .mobile-modal-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow: hidden;
    }
    
    .mobile-modal-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .mobile-modal-footer {
      padding: 12px 16px;
      border-top: 1px solid #eee;
      background: #f8f9fa;
    }
    
    .mobile-image-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .mobile-quality-indicator {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .mobile-quality-indicator.high {
      background: #4CAF50;
      color: white;
    }
    
    .mobile-quality-indicator.medium {
      background: #FF9800;
      color: white;
    }
    
    .mobile-quality-indicator.low {
      background: #f44336;
      color: white;
    }
    
    .mobile-image-url {
      font-size: 10px;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }
    
    .mobile-image-card {
      background: white; border-radius: 12px; overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08); cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      break-inside: avoid; position: relative;
    }
    .mobile-image-card:hover {
      transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    }
    
    .mobile-image-card img {
      width: 100%; height: auto; display: block; 
      border-radius: 12px; opacity: 0; transition: opacity 0.3s ease;
    }
    .mobile-image-card img.loaded {
      opacity: 1;
    }
    
    .quality-badge {
      position: absolute; top: 6px; right: 6px;
      padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: 500;
      background: rgba(255,255,255,0.9); color: #333; backdrop-filter: blur(4px);
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    .quality-high { background: rgba(76,175,80,0.9); color: white; }
    .quality-medium { background: rgba(255,193,7,0.9); color: white; }
    .quality-low { background: rgba(158,158,158,0.9); color: white; }
    
    /* Creative Attached Tag Icon (bottom-right) */
    .mobile-tag-icon {
      position: absolute;
      bottom: -3px;
      right: -3px;
      width: 28px;
      height: 36px;
      background: linear-gradient(135deg, #2196F3, #1976D2);
      clip-path: polygon(0% 0%, 100% 0%, 100% 70%, 50% 100%, 0% 70%);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 4px;
      color: white;
      font-size: 12px;
      transform: rotate(12deg);
      box-shadow: 0 3px 8px rgba(0,0,0,0.25);
      z-index: 10;
      transition: all 0.2s ease;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .mobile-tag-icon:before {
      content: 'üè∑Ô∏è';
      font-size: 14px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
    }
    
    .mobile-image-card:hover .mobile-tag-icon {
      transform: rotate(12deg) scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    }
    
    /* Tag attachment hole effect */
    .mobile-tag-icon:after {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div class="row">
    <input id="urlInput" type="text" placeholder="Paste product URL" />
    <button id="visitBtn">Load</button>
    <button id="memoryBtn" title="Scrape using saved selector memory only">Selector memory</button>
    <button id="saveBtn" disabled>Save (scrape)</button>
    <!-- LLM (compare) button ‚Äî added -->
    <button id="llmCompareBtn" title="Side-by-side baseline vs LLM">LLM (compare)</button>
    <button id="batchAIBtn" title="Get AI suggestions for all fields at once (saves tokens)">ü§ñ Batch AI All</button>
    <button id="copyDiagnosticsBtn" title="Copy structured diagnostic information for troubleshooting">üìã Copy Diagnostics</button>
    <span id="aiCacheStatus" class="ai-cache-status">ü§ñ AI cache: Not Ready</span>
  </div>

  <div id="status"></div>


  <!-- Image Preview Modal -->
  <div id="imageModal" class="debug-image-modal" onclick="hideImageModal()">
    <img id="modalImage" src="" alt="Full Size Preview">
  </div>

  <style>
    .debug-image-preview {
      display: inline-block;
      margin: 2px 5px 2px 0;
      border: 2px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      vertical-align: middle;
    }
    
    .debug-image-preview.kept {
      border-color: #28a745;
    }
    
    .debug-image-preview.rejected {
      border-color: #dc3545;
    }
    
    .debug-image-preview img {
      width: 50px;
      height: 50px;
      object-fit: cover;
      display: block;
    }
    
    .debug-image-preview .score {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #007bff;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    
    .debug-image-preview.rejected .score {
      background: #dc3545;
    }
    
    .debug-image-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      cursor: pointer;
    }
    
    .debug-image-modal img {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 90%;
      max-height: 90%;
      border: 2px solid white;
    }
  </style>

  <div id="panel" class="grid" style="display:none; margin-top:12px;">
    <div class="box">
      <div class="label">Scrape Result</div>
      <div id="summary"></div>
      <div id="images" class="imgs" style="margin-top:6px;"></div>
    </div>
    <div class="box">
      <div class="label">Mobile Preview</div>
      <div id="validationPanel" style="margin-bottom: 12px; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 4px solid #2196F3;">
        <div style="font-weight: bold; margin-bottom: 6px; color: #333; font-size: 12px;">Device Toggle:</div>
        <div id="validationResults" style="font-size: 11px; line-height: 1.4;">
          <div id="mobileContainer" class="mobile-container iphone">
            <div id="mobileContent" class="mobile-content">
              <div id="mobileGrid" class="mobile-grid">
                <!-- Images will be populated here -->
              </div>
              <!-- In-Container Image Detail Modal -->
              <div id="mobileImageModal" class="mobile-image-modal">
                <div class="mobile-modal-header">
                  <button id="mobileBackBtn" class="mobile-back-btn">‚Üê</button>
                  <div class="mobile-header-space"></div>
                  <button id="mobileSaveBtn" class="mobile-save-btn">Save</button>
                </div>
                <div class="mobile-modal-content">
                  <img id="mobileModalImage" class="mobile-modal-image" src="" alt="Product image">
                </div>
                <div class="mobile-modal-footer">
                  <div class="mobile-image-info">
                    <div id="mobileImageQuality" class="mobile-quality-indicator"></div>
                    <div id="mobileImageUrl" class="mobile-image-url"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <button id="iphoneBtn" class="device-btn active" data-device="iphone" style="margin-right: 8px; padding: 4px 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">üì± iPhone</button>
        <button id="ipadBtn" class="device-btn" data-device="ipad" style="padding: 4px 8px; background: #ccc; color: #333; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">üì± iPad</button>
        <span style="font-size: 12px; color: #666; margin-left: 12px;" id="imageCount">0 images</span>
      </div>

      <div class="label">Selector Memory (approve to save)</div>
      <div>
        <label><input type="checkbox" id="okTitle"> Title OK</label>
        <button class="ai-suggest-btn" data-field="title">ü§ñ AI</button>
        <label style="margin-left:12px;"><input type="checkbox" id="okPrice"> Price OK</label>
        <button class="ai-suggest-btn" data-field="price">ü§ñ AI</button>
        <label style="margin-left:12px;"><input type="checkbox" id="okImages"> Images OK</label>
        <button class="ai-suggest-btn" data-field="images">ü§ñ AI</button>
        <br>
        <label><input type="checkbox" id="okBrand"> Brand OK</label>
        <button class="ai-suggest-btn" data-field="brand">ü§ñ AI</button>
        <label style="margin-left:12px;"><input type="checkbox" id="okTags"> Tags OK</label>
        <button class="ai-suggest-btn" data-field="tags">ü§ñ AI</button>
        <label style="margin-left:12px;"><input type="checkbox" id="okDesc"> Description OK</label>
        <button class="ai-suggest-btn" data-field="description">ü§ñ AI</button>
      </div>
      <div id="memDebug" style="margin-top:8px; font-size:12px; opacity:.8;"></div>
      <div style="margin-top:8px;">
        <button id="saveMemBtn">Save selectors for this host</button>
        <button id="clearMemBtn" style="background:#b22;">Clear memory (host)</button>
      </div>
      
      <!-- AI Suggestion Panel -->
      <div id="suggestionPanel" class="suggestion-panel">
        <div style="font-weight: bold; margin-bottom: 6px; color: #333; font-size: 12px;">
          ü§ñ AI Selector Suggestion for <span id="suggestionField"></span>:
        </div>
        <div class="suggestion-comparison">
          <div class="suggestion-box">
            <div style="font-weight: bold; color: #666; margin-bottom: 4px;">Current:</div>
            <div id="currentSelector"></div>
            <div style="margin-top: 4px; padding: 4px; background: #f9f9f9; border-radius: 2px; min-height: 20px;">
              <div style="font-size: 10px; color: #666; margin-bottom: 2px;">Preview:</div>
              <div id="currentPreview" style="font-size: 11px;">‚Äî</div>
            </div>
          </div>
          <div class="suggestion-box">
            <div style="font-weight: bold; color: #4CAF50; margin-bottom: 4px;">AI Suggestion:</div>
            <div id="aiSuggestion"></div>
            <div style="margin-top: 4px; padding: 4px; background: #f0f8f0; border-radius: 2px; min-height: 20px;">
              <div style="font-size: 10px; color: #666; margin-bottom: 2px;">Preview:</div>
              <div id="aiPreview" style="font-size: 11px;">‚Äî</div>
            </div>
          </div>
        </div>
        <div style="margin-top: 8px;">
          <button id="useSuggestionBtn" class="use-suggestion-btn">‚úÖ Use AI Suggestion</button>
          <button id="dismissSuggestionBtn" style="margin-left: 8px; padding: 4px 8px; background: #ccc; color: #333; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">‚ùå Keep Current</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Debug Panel (moved below scrape results) -->
  <div id="debugPanel" style="display:none; background:#f0f8ff; border:1px solid #ccc; margin:10px 0; padding:10px; border-radius:4px;">
    <h3 style="margin:0 0 10px 0;">üîç Debug Information</h3>
    <div id="debugOutput" style="font-family:monospace; font-size:12px; max-height:300px; overflow-y:auto; background:white; padding:8px; border:1px solid #ddd;"></div>
    <button onclick="clearDebugOutput()" style="margin-top:5px;">Clear Debug</button>
  </div>
  <div class="label" style="margin-top:10px;">Image URLs (top 20)</div>
  <div id="out" title="Only image URLs appear here"></div>

  <script>
    // Copy image URL to clipboard with visual feedback
    function copyImageURL(url, element) {
      navigator.clipboard.writeText(url).then(() => {
        const originalText = element.textContent;
        const originalBg = element.style.backgroundColor;
        element.style.backgroundColor = '#4CAF50';
        element.style.color = 'white';
        element.textContent = '‚úÖ Copied!';
        
        setTimeout(() => {
          element.style.backgroundColor = originalBg;
          element.style.color = '';
          element.textContent = originalText;
        }, 1500);
      }).catch(err => {
        alert('Failed to copy URL: ' + err.message);
      });
    }

    // Event delegation for copy URL functionality
    document.addEventListener('click', function(e) {
      if (e.target.classList.contains('copy-url-span') || e.target.classList.contains('copy-url-btn')) {
        const url = e.target.getAttribute('data-url');
        if (url) {
          copyImageURL(url, e.target);
        }
      }
    });
    
    const urlInput = document.getElementById('urlInput');
    const visitBtn = document.getElementById('visitBtn');
    const memoryBtn = document.getElementById('memoryBtn');
    const saveBtn  = document.getElementById('saveBtn');
    const statusEl = document.getElementById('status');

    const panel = document.getElementById('panel');
    const summary = document.getElementById('summary');
    const images = document.getElementById('images');
    const out = document.getElementById('out');

    const okTitle = document.getElementById('okTitle');
    const okPrice = document.getElementById('okPrice');
    const okImages = document.getElementById('okImages');
    const okBrand = document.getElementById('okBrand');
    const okTags  = document.getElementById('okTags');
    const okDesc  = document.getElementById('okDesc');
    const saveMemBtn = document.getElementById('saveMemBtn');
    const clearMemBtn = document.getElementById('clearMemBtn');
    const memDebug = document.getElementById('memDebug');
    const validateBtn = document.getElementById('validateBtn');
    const validationResults = document.getElementById('validationResults');

    function setSaveState(disabled, label) {
      saveBtn.disabled = disabled;
      saveBtn.textContent = label || (disabled ? 'Waiting for page‚Ä¶' : 'Save (scrape)');
    }
    function hostFrom(url) {
      try { 
        // Use consistent domain normalization
        const hostname = new URL(url).hostname;
        return hostname.toLowerCase().replace(/^www\./, '');
      } catch { return null; }
    }

    let currentHost = null;
    let lastSelectorsUsed = null;
    let lastPayload = null;
    let currentUrl = ''; // Fixed: moved from line 808 to prevent initialization error

    function normalizeSelectorInfo(selectorInfo) {
      if (!selectorInfo) return null;
      if (selectorInfo && Array.isArray(selectorInfo.selectors)) {
        const sels = selectorInfo.selectors.filter(Boolean).slice(0, 8);
        return { selectors: sels, attr: selectorInfo.attr || 'text', method: selectorInfo.method || 'tracked' };
      }
      if (selectorInfo && typeof selectorInfo.selector === 'string') {
        const s = selectorInfo.selector;
        if (/^(generic-text-selector|custom-handler|generic-images)$/i.test(s)) return null;
        return { selectors: [s], attr: selectorInfo.attr || 'text', method: selectorInfo.method || 'tracked' };
      }
      if (typeof selectorInfo === 'string') {
        const s = selectorInfo.trim();
        const looksCss = /[#.\[\s>:]/.test(s) || s.startsWith('meta') || s.startsWith('img');
        if (!looksCss) return null;
        return { selectors: [s], attr: 'text', method: 'tracked' };
      }
      return null;
    }

    // Load (navigate only)
    visitBtn.onclick = async () => {
      const url = urlInput.value.trim();
      if (!url) return;
      currentUrl = url; // Track current URL for cache
      currentHost = hostFrom(url);
      panel.style.display = 'none';
      out.textContent = '';
      images.innerHTML = '';
      summary.innerHTML = '';
      statusEl.innerHTML = `<span class="pill">Loading ${currentHost}</span>`;
      await window.api.openProduct(url);
      

      // poll readiness and enable Save once likely hydrated
      setSaveState(true, 'Waiting for page‚Ä¶');
      const iv = setInterval(async () => {
        console.log('üîç Polling for page readiness...');
        const ok = await window.api.evalInProduct(`
          (async () => {
            const h1 = document.querySelector("h1,[itemprop='name']");
            const price = document.querySelector("[itemprop='price'],[data-price],[class*='price'] .money");
            const imgs = document.querySelector("img[src], picture source[srcset], [data-zoom-image], [data-large-image]");
            return !!(h1 && (price || imgs));
          })();
        `);
        if (ok) {
          clearInterval(iv);
          statusEl.innerHTML = `<span class="pill">Ready</span>`;
          setSaveState(false);
          setTimeout(autoValidateIfNeeded, 500);
        }
      }, 700);
    };

    // Selector memory only
    memoryBtn.onclick = async () => {
      const url = urlInput.value.trim();
      if (!url) return alert('Paste a URL first.');
      const host = hostFrom(url);
      // First navigate to the target page to be in correct origin
      statusEl.innerHTML = `<span class="pill">Loading ${host}</span>`;
      panel.style.display = 'none'; images.innerHTML=''; summary.innerHTML=''; out.textContent='';
      
      await window.api.openProduct(url);
      await new Promise(r => setTimeout(r, 1500)); // Wait for page load
      
      const hasMem = await window.api.hasSelectorMemory(host);
      if (!hasMem) { 
        statusEl.innerHTML = `<span class="pill" style="background:#fdd; color:#900;">No Memory</span>`;
        alert('‚ùå No selector memory for this host yet. Use "Save (Scrape)" first.');
        return;
      }
      
      statusEl.innerHTML = `<span class="pill">Memory-only</span>`;
      try {
        const { result, selectorsUsed } = await window.api.scrapeCurrent({ mode: 'memoryOnly' });
        lastPayload = result || {}; lastSelectorsUsed = selectorsUsed || null;
        const imgs = Array.isArray(result?.images) ? result.images : [];
        summary.innerHTML = `
          <div><b>Title:</b> ${result?.title || ''}</div>
          <div><b>Price:</b> ${result?.price || ''}</div>
          <div><b>Brand:</b> ${result?.brand || ''}</div>
          <div><b>URL:</b> ${result?.url || ''}</div>
          <div><b>Description:</b> ${(result?.description || '').slice(0,240)}</div>`;
        images.innerHTML = imgs.map(u => `<img referrerpolicy="no-referrer" src="${u}" title="${u}" onclick="openImageOverlay('${u}')">`).join('');
        // Update mobile preview with scraped images
        updateMobilePreview(imgs);
        // Enhanced URL display with click-to-copy functionality (safe DOM approach)
        out.innerHTML = ''; // Clear first
        imgs.forEach((url, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'image-url-item';
          itemDiv.style.cssText = `display: flex; align-items: center; padding: 4px 0; border-bottom: 1px solid #eee; background: ${index % 2 === 0 ? '#f9f9f9' : 'white'};`;
          
          const urlSpan = document.createElement('span');
          urlSpan.className = 'copy-url-span';
          urlSpan.setAttribute('data-url', url);
          urlSpan.style.cssText = 'flex: 1; font-family: monospace; font-size: 11px; word-break: break-all; cursor: pointer; padding: 4px;';
          urlSpan.title = 'Click to copy full URL: ' + url;
          urlSpan.textContent = 'üìã ' + url;
          
          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-url-btn';
          copyBtn.setAttribute('data-url', url);
          copyBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 10px; cursor: pointer; border: 1px solid #ddd; border-radius: 3px; background: #f5f5f5;';
          copyBtn.textContent = 'Copy';
          
          itemDiv.appendChild(urlSpan);
          itemDiv.appendChild(copyBtn);
          out.appendChild(itemDiv);
        });
        panel.style.display = 'grid';
        statusEl.innerHTML = `<span class="pill">Done</span>`;
      } catch (e) {
        out.textContent = 'Error: ' + (e?.message || String(e));
        statusEl.innerHTML = `<span class="pill" style="background:#fdd; color:#900;">Error</span>`;
      }
    };

    // Save (scrape)
    saveBtn.onclick = async () => {
      // Show debug panel and clear previous output
      showDebugPanel();
      clearDebugOutput();
      addDebugOutput('üöÄ Starting scrape operation for: ' + (urlInput.value || 'current page'), 'info');
      
      statusEl.innerHTML = `<span class="pill">Scraping</span>`;
      panel.style.display = 'none'; images.innerHTML=''; summary.innerHTML=''; out.textContent='';
      try {
        const { result, selectorsUsed } = await window.api.scrapeCurrent({ mode: 'normal' });
        lastPayload = result || {}; lastSelectorsUsed = selectorsUsed || null;
        
        // Display debug log if available
        if (result && result.__debugLog && Array.isArray(result.__debugLog)) {
          result.__debugLog.forEach(entry => {
            const colors = { info: 'info', warning: 'warning', error: 'error', debug: 'debug' };
            
            if (entry.isImage && entry.imageUrl) {
              // Use visual image preview for image debug entries
              addDebugOutputWithImage(
                entry.message, 
                colors[entry.level] || 'info', 
                entry.imageUrl, 
                entry.score, 
                entry.kept
              );
            } else {
              // Regular text debug output
              addDebugOutput(entry.message, colors[entry.level] || 'info');
            }
          });
          addDebugOutput('‚úÖ Debug trace complete', 'success');
        }
        const imgs = Array.isArray(result?.images) ? result.images : [];
        summary.innerHTML = `
          <div><b>Title:</b> ${result?.title || ''}</div>
          <div><b>Price:</b> ${result?.price || ''}</div>
          <div><b>Brand:</b> ${result?.brand || ''}</div>
          <div><b>URL:</b> ${result?.url || ''}</div>
          <div><b>Description:</b> ${(result?.description || '').slice(0,240)}</div>`;
        images.innerHTML = imgs.map(u => `<img referrerpolicy="no-referrer" src="${u}" title="${u}" onclick="openImageOverlay('${u}')">`).join('');
        // Update mobile preview with scraped images
        updateMobilePreview(imgs);
        // Enhanced URL display with click-to-copy functionality (safe DOM approach)
        out.innerHTML = ''; // Clear first
        imgs.forEach((url, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'image-url-item';
          itemDiv.style.cssText = `display: flex; align-items: center; padding: 4px 0; border-bottom: 1px solid #eee; background: ${index % 2 === 0 ? '#f9f9f9' : 'white'};`;
          
          const urlSpan = document.createElement('span');
          urlSpan.className = 'copy-url-span';
          urlSpan.setAttribute('data-url', url);
          urlSpan.style.cssText = 'flex: 1; font-family: monospace; font-size: 11px; word-break: break-all; cursor: pointer; padding: 4px;';
          urlSpan.title = 'Click to copy full URL: ' + url;
          urlSpan.textContent = 'üìã ' + url;
          
          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-url-btn';
          copyBtn.setAttribute('data-url', url);
          copyBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 10px; cursor: pointer; border: 1px solid #ddd; border-radius: 3px; background: #f5f5f5;';
          copyBtn.textContent = 'Copy';
          
          itemDiv.appendChild(urlSpan);
          itemDiv.appendChild(copyBtn);
          out.appendChild(itemDiv);
        });
        panel.style.display = 'grid';
        statusEl.innerHTML = `<span class="pill">Done</span>`;
      } catch (e) {
        out.textContent = 'Error: ' + (e?.message || String(e));
        statusEl.innerHTML = `<span class="pill" style="background:#fdd; color:#900;">Error</span>`;
      }
    };

    // Save selector memory (unchanged)
    saveMemBtn.onclick = async () => {
      const host = currentHost;
      if (!host || !lastPayload) return;
      let displayResults = [];
      const fieldChecks = [
        { field: 'title', checked: okTitle.checked, data: lastPayload.title },
        { field: 'price', checked: okPrice.checked, data: lastPayload.price },
        { field: 'brand', checked: okBrand.checked, data: lastPayload.brand },
        { field: 'description', checked: okDesc.checked, data: lastPayload.description },
        { field: 'images', checked: okImages.checked, data: lastPayload.images }
      ];
      const foundSelectors = {};
      for (const { field, checked, data } of fieldChecks) {
        if (checked && data && lastSelectorsUsed?.[field]) {
          const norm = normalizeSelectorInfo(lastSelectorsUsed[field]);
          if (norm?.selectors?.length) {
            foundSelectors[field] = { selectors: norm.selectors, attr: norm.attr, method: norm.method };
            displayResults.push(`‚úì ${field}: ${norm.selectors.join(', ')}`);
          } else {
            displayResults.push(`‚ùå ${field}: no valid selector`);
          }
        }
      }
      if (!Object.keys(foundSelectors).length) {
        memDebug.innerHTML = `<div style="color:#d32f2f;">‚ùå No tracked selectors available to save.</div>`;
        return;
      }
      await window.api.setSelectorMemory(host, foundSelectors, `Saved ${new Date().toISOString()}`);
      memDebug.innerHTML = `<div style="color:#2d5a27;">‚úÖ Saved selectors.</div>`;
    };

    clearMemBtn.onclick = async () => {
      if (!currentHost) return;
      const confirmed = confirm('Clear all saved selectors for this domain?');
      if (!confirmed) return;
      await window.api.clearSelectorMemory(currentHost);
      memDebug.innerHTML = '<div style="color:#666;">No saved selectors for this domain</div>';
      validationResults.innerHTML = '<div style="color:#666; font-style:italic;">No saved selectors found</div>';
      alert('Cleared.');
    };

    validateBtn.onclick = async () => {
      if (!currentHost) return;
      validateBtn.textContent = 'Testing‚Ä¶'; validateBtn.disabled = true;
      try {
        const results = await window.api.validateSelectors(currentHost);
        displayValidationResults(results);
      } finally {
        validateBtn.textContent = 'Test Saved Selectors'; validateBtn.disabled = false;
      }
    };

    function displayValidationResults(results) {
      if (!results.savedSelectors || Object.keys(results.savedSelectors).length === 0) {
        validationResults.innerHTML = '<div style="color:#666; font-style:italic;">No saved selectors found for this domain</div>';
        return;
      }
      const fieldResults = [];
      Object.entries(results.savedSelectors).forEach(([field, selectorConfig]) => {
        const testResult = results.testResults[field];
        const status = testResult?.success || false;
        const value = testResult?.value ?? '';
        const error = testResult?.error || '';
        const source = testResult?.source || 'unknown';
        let icon, color, statusText;
        if (status) {
          icon = '‚úÖ'; color = '#2d5a27';
          const valueStr = Array.isArray(value) ? `${value.length} items` : String(value);
          const truncatedValue = valueStr.slice(0, 60) + (valueStr.length > 60 ? '...' : '');
          const sourceInfo = source === 'memory' ? '(saved selector)' : source === 'generic-fallback' ? '(fallback)' : '';
          statusText = `Found: "${truncatedValue}" ${sourceInfo}`;
        } else {
          icon = '‚ùå'; color = '#d32f2f'; statusText = error || 'Not found';
        }
        const selectors = Array.isArray(selectorConfig.selectors) ? selectorConfig.selectors : [selectorConfig.selectors];
        fieldResults.push(`
          <div style="margin-bottom:4px; padding:3px 0;">
            <span style="color:${color};">${icon}</span>
            <strong>${field}:</strong> 
            <code style="background:#eee; padding:1px 4px; border-radius:2px; font-size:10px;">${selectors.join(', ')}</code>
            <div style="font-size:10px; color:#666; margin-left:20px;">${statusText}</div>
          </div>`);
      });
      const successCount = Object.values(results.testResults).filter(r => r && r.success).length;
      const totalCount = Object.keys(results.savedSelectors).length;
      validationResults.innerHTML = `
        <div style="margin-bottom:6px; font-weight:bold; color:#333;">Results (${successCount}/${totalCount} working):</div>
        ${fieldResults.join('')}`;
    }

    async function autoValidateIfNeeded() {
      if (!currentHost) return;
      try {
        const memory = await window.api.getSelectorMemory(currentHost);
        if (memory && Object.keys(memory).length > 0) {
          const results = await window.api.validateSelectors(currentHost);
          displayValidationResults(results);
        }
      } catch {}
    }

    // AI Suggestion workflow
    const suggestionPanel = document.getElementById('suggestionPanel');
    const suggestionField = document.getElementById('suggestionField');
    const currentSelector = document.getElementById('currentSelector');
    const aiSuggestion = document.getElementById('aiSuggestion');
    const currentPreview = document.getElementById('currentPreview');
    const aiPreview = document.getElementById('aiPreview');
    const useSuggestionBtn = document.getElementById('useSuggestionBtn');
    const dismissSuggestionBtn = document.getElementById('dismissSuggestionBtn');
    
    let currentSuggestionData = null;

    // Test selectors on current page to preview content
    async function testExtractInProduct(field, selectors, attr) {
      if (!selectors || !selectors.length) return null;
      
      const code = `(() => {
        const qa = (s) => Array.from(document.querySelectorAll(s));
        const txt = (el) => (el && (el.textContent||'').trim()) || null;
        const pickFromSrcset = (ss) => { 
          if(!ss) return null; 
          const p = ss.split(',').map(s => s.trim()); 
          const last = p[p.length-1] || ''; 
          return (last.split(' ')[0]) || null; 
        };
        const uniq = (arr) => Array.from(new Set(arr.filter(Boolean)));
        
        const sels = ${JSON.stringify(selectors)};
        const attrName = ${JSON.stringify(attr)};
        const field = ${JSON.stringify(field)};
        
        for (const sel of sels) {
          try {
            if (field === 'images') {
              const urls = [];
              for (const el of qa(sel)) {
                const s1 = el.getAttribute('src') || el.currentSrc || 
                          el.getAttribute('data-src') || el.getAttribute('data-image') || 
                          el.getAttribute('data-zoom-image') || el.getAttribute('data-large');
                if (s1) urls.push(s1);
                
                const ss = el.getAttribute('srcset'); 
                const best = pickFromSrcset(ss); 
                if (best) urls.push(best);
                
                if (el.parentElement && el.parentElement.tagName.toLowerCase() === 'picture') {
                  for (const src of el.parentElement.querySelectorAll('source')) {
                    const b = pickFromSrcset(src.getAttribute('srcset')); 
                    if (b) urls.push(b);
                  }
                }
              }
              const out = uniq(urls).slice(0, 6);
              if (out.length) return out;
            } else {
              const el = document.querySelector(sel); 
              if (!el) continue;
              const v = attrName === 'text' ? txt(el) : el.getAttribute(attrName);
              if (v && String(v).trim()) return String(v).trim();
            }
          } catch(_) {}
        }
        return null;
      })()`;
      
      return await window.api.evalInProduct(code);
    }

    // Render preview content in UI
    function renderPreview(element, field, value) {
      if (!value || (Array.isArray(value) && !value.length)) {
        element.innerHTML = '<span style="color:#999; font-style:italic;">No match</span>';
        return;
      }
      
      if (field === 'images') {
        // Create unique gallery ID and store images globally
        const galleryId = 'gallery_' + Math.random().toString(36).substr(2, 9);
        imageGalleries[galleryId] = value;
        
        element.innerHTML = value.map((url, index) => 
          `<img referrerpolicy="no-referrer" src="${url}" 
           style="height:30px; width:auto; margin:2px; border:1px solid #ddd; border-radius:2px; vertical-align:top; cursor:pointer;" 
           onclick="openImageGallery(imageGalleries['${galleryId}'], ${index})"
           title="Click to enlarge (${index + 1}/${value.length})" 
           onerror="this.style.display='none'">`
        ).join('');
      } else {
        const displayValue = Array.isArray(value) ? String(value[0]) : String(value);
        const truncated = displayValue.slice(0, 120) + (displayValue.length > 120 ? '...' : '');
        element.textContent = truncated;
        element.title = displayValue; // Full text on hover
      }
    }

    // AI cache state tracking
    let aiCacheReady = false;
    let llmCacheExists = false;
    let cachedLLMResults = null;
    
    function updateAICacheStatus(ready) {
      aiCacheReady = ready;
      const statusEl = document.getElementById('aiCacheStatus');
      const aiButtons = document.querySelectorAll('.ai-suggest-btn');
      
      if (ready) {
        statusEl.textContent = 'ü§ñ AI cache: Ready';
        statusEl.className = 'ai-cache-status ready';
        aiButtons.forEach(btn => btn.disabled = false);
      } else {
        statusEl.textContent = 'ü§ñ AI cache: Not Ready';
        statusEl.className = 'ai-cache-status';
        aiButtons.forEach(btn => btn.disabled = true);
      }
    }
    
    // Check for persistent LLM cache when URL changes
    async function checkLLMCache() {
      if (!currentUrl) return;
      
      try {
        llmCacheExists = await window.api.checkLLMCache(currentUrl);
        cachedLLMResults = llmCacheExists ? await window.api.getLLMCache(currentUrl) : null;
        
        if (llmCacheExists && cachedLLMResults) {
          console.log('LLM cache found for:', currentUrl);
          updateAICacheStatus(true);
          showLLMCacheWarning();
        } else {
          updateAICacheStatus(false);
          hideLLMCacheWarning();
        }
      } catch (e) {
        console.error('Error checking LLM cache:', e);
        llmCacheExists = false;
        cachedLLMResults = null;
        updateAICacheStatus(false);
      }
    }
    
    function showLLMCacheWarning() {
      let warning = document.getElementById('llm-cache-warning');
      if (!warning) {
        warning = document.createElement('div');
        warning.id = 'llm-cache-warning';
        warning.style.cssText = `
          background: #fff3cd;
          border: 1px solid #ffeaa7;
          border-radius: 4px;
          padding: 8px 12px;
          margin: 8px 0;
          font-size: 13px;
          color: #856404;
        `;
        
        const cacheTime = cachedLLMResults ? new Date(cachedLLMResults.timestamp).toLocaleString() : 'Unknown';
        warning.innerHTML = `
          ‚ö†Ô∏è <strong>LLM cache found</strong> - Using cached AI results from ${cacheTime}
          <button onclick="clearLLMCache()" style="margin-left:10px; padding:2px 6px; font-size:11px;">Clear Cache</button>
        `;
        
        // Insert after URL input row
        const urlInput = document.getElementById('urlInput');
        if (urlInput && urlInput.parentNode) {
          const row = urlInput.parentNode;
          row.parentNode.insertBefore(warning, row.nextSibling);
        }
      }
      warning.style.display = 'block';
    }
    
    function hideLLMCacheWarning() {
      const warning = document.getElementById('llm-cache-warning');
      if (warning) {
        warning.style.display = 'none';
      }
    }
    
    async function clearLLMCache() {
      if (!currentUrl) return;
      
      try {
        await window.api.deleteLLMCache(currentUrl);
        llmCacheExists = false;
        cachedLLMResults = null;
        updateAICacheStatus(false);
        hideLLMCacheWarning();
        console.log('LLM cache cleared for:', currentUrl);
      } catch (e) {
        console.error('Error clearing LLM cache:', e);
      }
    }
    window.clearLLMCache = clearLLMCache; // Make globally accessible for onclick handlers
    
    // Debug panel functions
    function showDebugPanel() {
      document.getElementById('debugPanel').style.display = 'block';
    }
    
    function hideDebugPanel() {
      document.getElementById('debugPanel').style.display = 'none';
    }
    
    function addDebugOutput(message, type = 'info') {
      const output = document.getElementById('debugOutput');
      const timestamp = new Date().toLocaleTimeString();
      const colors = {
        info: '#333',
        success: '#28a745', 
        warning: '#ffc107',
        error: '#dc3545',
        debug: '#6c757d'
      };
      
      const div = document.createElement('div');
      div.style.color = colors[type] || colors.info;
      div.style.marginBottom = '2px';
      div.textContent = `[${timestamp}] ${message}`;
      
      output.appendChild(div);
      output.scrollTop = output.scrollHeight; // Auto-scroll to bottom
    }
    
    function clearDebugOutput() {
      document.getElementById('debugOutput').innerHTML = '';
    }
    
    // Enhanced debug output with image preview
    function addDebugOutputWithImage(message, type = 'info', imageUrl = null, score = null, kept = true) {
      const output = document.getElementById('debugOutput');
      const timestamp = new Date().toLocaleTimeString();
      const colors = {
        info: '#333',
        success: '#28a745', 
        warning: '#ffc107',
        error: '#dc3545',
        debug: '#6c757d'
      };
      
      const div = document.createElement('div');
      div.style.color = colors[type] || colors.info;
      div.style.marginBottom = '5px';
      div.style.display = 'flex';
      div.style.alignItems = 'center';
      
      const textSpan = document.createElement('span');
      textSpan.textContent = `[${timestamp}] ${message}`;
      div.appendChild(textSpan);
      
      if (imageUrl) {
        const previewDiv = document.createElement('div');
        previewDiv.className = `debug-image-preview ${kept ? 'kept' : 'rejected'}`;
        previewDiv.onclick = () => showImageModal(imageUrl);
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.onerror = () => {
          img.style.display = 'none';
          const errorSpan = document.createElement('span');
          errorSpan.textContent = ' [IMG ERROR]';
          errorSpan.style.color = '#dc3545';
          previewDiv.appendChild(errorSpan);
        };
        previewDiv.appendChild(img);
        
        if (score !== null) {
          const scoreDiv = document.createElement('div');
          scoreDiv.className = 'score';
          scoreDiv.textContent = score;
          previewDiv.appendChild(scoreDiv);
        }
        
        div.appendChild(previewDiv);
        
        // Add individual copy button for this image URL
        const copyBtn = document.createElement('button');
        copyBtn.className = 'debug-copy-btn';
        copyBtn.style.cssText = 'margin-left: 8px; padding: 2px 6px; font-size: 10px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;';
        copyBtn.textContent = 'üìã Copy URL';
        copyBtn.title = 'Copy image URL: ' + imageUrl;
        copyBtn.onclick = (e) => {
          e.stopPropagation(); // Prevent triggering the modal
          copyImageURL(imageUrl, copyBtn);
        };
        
        div.appendChild(copyBtn);
      }
      
      output.appendChild(div);
      output.scrollTop = output.scrollHeight;
    }
    
    // Image modal functions
    function showImageModal(imageUrl) {
      const modal = document.getElementById('imageModal');
      const modalImg = document.getElementById('modalImage');
      modalImg.src = imageUrl;
      modal.style.display = 'block';
    }
    
    function hideImageModal() {
      document.getElementById('imageModal').style.display = 'none';
    }
    
    // Make debug functions globally accessible
    window.showDebugPanel = showDebugPanel;
    window.addDebugOutput = addDebugOutput;
    window.addDebugOutputWithImage = addDebugOutputWithImage;
    window.showImageModal = showImageModal;
    window.hideImageModal = hideImageModal;
    window.clearDebugOutput = clearDebugOutput;
    
    // Initialize with disabled state
    updateAICacheStatus(false);
    
    // Add event listeners to all AI suggestion buttons
    document.querySelectorAll('.ai-suggest-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        if (!aiCacheReady) {
          e.preventDefault();
          alert('‚ö†Ô∏è Run ü§ñ Batch AI All first!\n\nIndividual AI buttons work by retrieving from the batch AI cache. Please run Batch AI All to warm the cache, then use individual buttons to review specific fields.');
          return;
        }
        
        const field = btn.getAttribute('data-field');
        await handleAISuggestion(field, btn);
      });
    });
    
    // Add batch AI button functionality
    document.getElementById('batchAIBtn')?.addEventListener('click', async () => {
      await handleBatchAISuggestion();
    });

    async function handleAISuggestion(field, button) {
      if (!currentHost) {
        alert('Please load a page first');
        return;
      }

      button.disabled = true;
      button.textContent = 'ü§ñ ...';
      
      try {
        const url = urlInput.value.trim();
        let response;
        
        // Check if we have cached results first
        if (llmCacheExists && cachedLLMResults && cachedLLMResults.results) {
          const fieldResult = cachedLLMResults.results[field];
          if (fieldResult && fieldResult.ok) {
            console.log(`Using cached result for ${field}`);
            response = fieldResult; // Use cached result directly
          }
        }
        
        // If no cached result, make new API call
        if (!response) {
          response = await window.api.llmPropose({
            url: url,
            label: field
          });
        }

        // Handle new intelligent validation response format
        let selectors = null;
        let validatedContent = null;
        let allCandidates = null;
        
        if (response.ok && response.selectors) {
          // New validated format with tested selectors
          selectors = Array.isArray(response.selectors) ? response.selectors : [response.selectors];
          validatedContent = response.chosenValue;
          allCandidates = response.allCandidates;
        } else if (response.result && response.result.selectors) {
          // Fallback for nested format
          selectors = Array.isArray(response.result.selectors) ? response.result.selectors : [response.result.selectors];
        } else if (Array.isArray(response)) {
          // Legacy array format
          selectors = response;
        }
        
        if (!selectors || selectors.length === 0) {
          const errorMsg = response.error || allCandidates?.length > 0 ? 
            'AI found selectors but none passed validation on this page' : 
            'AI could not find any selectors for this field';
          alert(`${errorMsg}. Field: ${field}`);
          return;
        }

        // Get current saved selector if any
        const memory = await window.api.getSelectorMemory(currentHost);
        const currentSelectorData = memory && memory[field] ? memory[field] : null;

        // Show suggestion panel with validated content
        await showSuggestionComparison(field, currentSelectorData, selectors, validatedContent, allCandidates);
        
      } catch (error) {
        alert(`Error getting AI suggestions: ${error.message}`);
      } finally {
        button.disabled = false;
        button.textContent = 'ü§ñ AI';
      }
    }

    async function handleBatchAISuggestion() {
      if (!currentHost) {
        alert('Please load a page first');
        return;
      }
      
      const batchBtn = document.getElementById('batchAIBtn');
      const originalText = batchBtn.textContent;
      batchBtn.textContent = '‚è≥ Processing...';
      batchBtn.disabled = true;
      
      try {
        const url = urlInput.value || 'unknown';
        const allFields = ['title', 'price', 'images', 'brand', 'tags', 'description'];
        
        // Use the new batch API
        const response = await window.api.llmPropose({
          url: url,
          fields: allFields // Multi-field batch request
        });
        
        let resultMsg = '';
        let foundSuggestions = 0;
        let tokensSaved = 0;
        let results = null;  // Declare results outside the if statement
        
        if (response.ok && response.results) {
          // Handle batch response format
          results = response.results;
          const optimization = response.optimization || {};
          
          // Check if this is from cache
          if (response.fromCache) {
            const cacheTime = new Date(response.cacheTimestamp).toLocaleString();
            resultMsg = `üìÑ Using cached AI results from ${cacheTime}`;
            tokensSaved = 0; // No tokens used when using cache
          } else {
            tokensSaved = optimization.tokensSaved || 0;
            const fieldsSkipped = optimization.fieldsSkipped || 0;
            
            resultMsg = `üéØ Optimization: ${Math.round(tokensSaved/1000)}K tokens saved`;
            if (fieldsSkipped > 0) {
              resultMsg += `, ${fieldsSkipped} fields found via heuristics`;
            }
          }
          
          // Process each field result
          for (const [field, result] of Object.entries(results)) {
            if (result.ok && result.selectors && result.selectors.length > 0) {
              foundSuggestions++;
              
              // Get current saved selector
              const memory = await window.api.getSelectorMemory(currentHost);
              const currentSelectorData = memory && memory[field] ? memory[field] : null;
              
              // Auto-apply good heuristic results
              if (result.source === 'heuristic' && result.chosenValue) {
                await applyAISuggestion(field, result, currentSelectorData);
                resultMsg += `\n‚úÖ ${field}: Auto-applied (${result.source})`;
              } else if (result.source === 'llm' && result.chosenValue) {
                // For LLM results, show comparison (for now just apply the first one)
                await applyAISuggestion(field, result, currentSelectorData);
                resultMsg += `\n‚úÖ ${field}: Applied (${result.source})`;
              } else {
                resultMsg += `\n‚ùå ${field}: ${result.error || 'No good selectors found'}`;
              }
            } else {
              resultMsg += `\n‚ùå ${field}: ${result.error || 'No suggestions'}`;
            }
          }
          
        } else {
          resultMsg = `‚ùå Batch AI failed: ${response.error || 'Unknown error'}`;
        }
        
        // Show validation panel instead of alert
        showValidationPanel(results, resultMsg, foundSuggestions);
        
        // Enable AI cache for individual buttons
        if (foundSuggestions > 0) {
          updateAICacheStatus(true);
        }
        
        // Auto-validate to show results
        await autoValidateIfNeeded();
        
      } catch (error) {
        alert(`Error with batch AI: ${error.message}`);
      } finally {
        batchBtn.textContent = originalText;
        batchBtn.disabled = false;
      }
    }
    
    // Helper function to apply an AI suggestion automatically
    async function applyAISuggestion(field, aiResult, currentSelectorData) {
      try {
        const memory = await window.api.getSelectorMemory(currentHost) || {};
        
        const dataToSave = {
          ...memory,
          [field]: {
            selectors: aiResult.selectors,
            attr: getDefaultAttr(field)
          }
        };
        
        await window.api.setSelectorMemory(currentHost, dataToSave, `Batch AI suggestion for ${field}`);
        
        // Check the corresponding checkbox
        const checkboxMap = {
          'title': 'okTitle',
          'price': 'okPrice', 
          'images': 'okImages',
          'brand': 'okBrand',
          'tags': 'okTags',
          'description': 'okDesc'
        };
        const checkbox = document.getElementById(checkboxMap[field]);
        if (checkbox) checkbox.checked = true;
        
      } catch (error) {
        console.error(`Error applying AI suggestion for ${field}:`, error);
      }
    }
    
    // Helper function to auto-validate selectors after changes
    async function autoValidateIfNeeded() {
      if (currentHost && validateBtn) {
        try {
          // Wait a bit for DOM to settle
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Trigger validation if button exists
          validateBtn.click();
        } catch (error) {
          console.log('Auto-validation skipped:', error);
        }
      }
    }

    async function showSuggestionComparison(field, current, suggestions, validatedContent = null, allCandidates = null) {
      suggestionField.textContent = field;
      
      // Display current selector
      if (current && current.selectors) {
        const currentSelectors = Array.isArray(current.selectors) ? current.selectors : [current.selectors];
        currentSelector.innerHTML = `
          <code style="background:#f5f5f5; padding:2px 4px; border-radius:2px; font-size:10px;">
            ${currentSelectors.join(', ')}
          </code>
          <div style="font-size:10px; color:#666; margin-top:2px;">Attribute: ${current.attr || 'text'}</div>
        `;
      } else {
        currentSelector.innerHTML = '<div style="color:#999; font-style:italic;">None saved</div>';
      }
      
      // Display AI suggestions
      aiSuggestion.innerHTML = `
        <code style="background:#e8f5e8; padding:2px 4px; border-radius:2px; font-size:10px;">
          ${suggestions.join(', ')}
        </code>
        <div style="font-size:10px; color:#666; margin-top:2px;">Attribute: ${getDefaultAttr(field)}</div>
      `;
      
      // Show panel and test current selectors
      suggestionPanel.style.display = 'block';
      currentPreview.innerHTML = 'Testing...';
      
      // Test current selectors only (AI selectors are already validated)
      const currentSelectors = (current && current.selectors) ? 
        (Array.isArray(current.selectors) ? current.selectors : [current.selectors]) : null;
      const currentAttr = (current && current.attr) || getDefaultAttr(field);
      
      try {
        // Test current selector
        const currentValue = currentSelectors ? 
          await testExtractInProduct(field, currentSelectors, currentAttr) : null;
        
        renderPreview(currentPreview, field, currentValue);
        
        // Show AI validated content (already tested and validated)
        if (validatedContent) {
          renderPreview(aiPreview, field, validatedContent);
          useSuggestionBtn.disabled = false;
          
          // Show additional info about validation
          if (allCandidates && allCandidates.length > 1) {
            const validatedCount = allCandidates.filter(c => c.validated).length;
            const testedCount = allCandidates.length;
            aiPreview.innerHTML += `<div style="font-size:10px; color:#666; margin-top:4px;">‚úÖ Validated (${validatedCount}/${testedCount} candidates tested)</div>`;
          }
        } else {
          aiPreview.innerHTML = '<span style="color:#999;">Testing...</span>';
          // Fallback to manual testing if no validated content provided
          const aiValue = await testExtractInProduct(field, suggestions, getDefaultAttr(field));
          renderPreview(aiPreview, field, aiValue);
          const hasContent = Array.isArray(aiValue) ? aiValue.length > 0 : (aiValue && String(aiValue).trim());
          useSuggestionBtn.disabled = !hasContent;
        }
        
        // Store suggestion data
        currentSuggestionData = {
          field: field,
          selectors: suggestions,
          attr: getDefaultAttr(field),
          validatedContent: validatedContent
        };
        
      } catch (error) {
        currentPreview.innerHTML = '<span style="color:#999;">Test failed</span>';
        aiPreview.innerHTML = '<span style="color:#999;">Test failed</span>';
        useSuggestionBtn.disabled = true;
        console.error('Preview test failed:', error);
      }
    }

    function getDefaultAttr(field) {
      if (field === 'images') return 'src';
      // Most elements use visible text, not meta content
      return 'text';
    }

    // Handle "Use AI Suggestion" button
    useSuggestionBtn.onclick = async () => {
      if (!currentSuggestionData || !currentHost) return;
      
      try {
        // Save the AI suggestion as the new selector
        const dataToSave = {
          [currentSuggestionData.field]: {
            selectors: currentSuggestionData.selectors,
            attr: currentSuggestionData.attr
          }
        };
        
        await window.api.setSelectorMemory(currentHost, dataToSave, `AI suggestion for ${currentSuggestionData.field}`);
        
        // Update UI
        memDebug.innerHTML = `<div style="color:#4CAF50;">‚úÖ Saved AI suggestion for ${currentSuggestionData.field}</div>`;
        
        // Check the corresponding checkbox
        const checkboxMap = {
          'title': 'okTitle',
          'price': 'okPrice', 
          'images': 'okImages',
          'brand': 'okBrand',
          'tags': 'okTags',
          'description': 'okDesc'  // Special case - different from field name
        };
        const checkbox = document.getElementById(checkboxMap[currentSuggestionData.field]);
        if (checkbox) checkbox.checked = true;
        
        // Hide suggestion panel
        suggestionPanel.style.display = 'none';
        currentSuggestionData = null;
        
        // Auto-validate to show the new selector working
        await autoValidateIfNeeded();
        
      } catch (error) {
        alert(`Error saving AI suggestion: ${error.message}`);
      }
    };

    // Handle "Keep Current" button
    dismissSuggestionBtn.onclick = () => {
      suggestionPanel.style.display = 'none';
      currentSuggestionData = null;
    };

    // Image overlay and gallery
    let currentImageGallery = [];
    let currentImageIndex = 0;
    let imageGalleries = {}; // Store galleries by ID to avoid JSON in attributes
    window.imageGalleries = imageGalleries; // Make globally accessible for onclick handlers
    
    function openImageOverlay(imageUrl) {
      const overlay = document.getElementById('imageOverlay');
      const overlayImage = document.getElementById('overlayImage');
      overlayImage.src = imageUrl;
      overlay.classList.add('show');
    }
    
    function openImageGallery(images, startIndex = 0) {
      currentImageGallery = images;
      currentImageIndex = startIndex;
      showCurrentImage();
      document.getElementById('imageOverlay').classList.add('show');
    }
    window.openImageGallery = openImageGallery; // Make globally accessible for onclick handlers
    
    function showCurrentImage() {
      if (currentImageGallery.length === 0) return;
      
      const overlayImage = document.getElementById('overlayImage');
      const imageUrl = currentImageGallery[currentImageIndex];
      overlayImage.src = imageUrl;
      
      // Update image counter if we add one later
      updateImageCounter();
    }
    
    function nextImage() {
      if (currentImageGallery.length === 0) return;
      currentImageIndex = (currentImageIndex + 1) % currentImageGallery.length;
      showCurrentImage();
    }
    
    function prevImage() {
      if (currentImageGallery.length === 0) return;
      currentImageIndex = (currentImageIndex - 1 + currentImageGallery.length) % currentImageGallery.length;
      showCurrentImage();
    }
    
    function updateImageCounter() {
      // Add image counter display
      const overlay = document.getElementById('imageOverlay');
      let counter = overlay.querySelector('.image-counter');
      
      if (!counter && currentImageGallery.length > 1) {
        counter = document.createElement('div');
        counter.className = 'image-counter';
        counter.style.cssText = 'position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px; z-index: 1001;';
        overlay.querySelector('.overlay-content').appendChild(counter);
      }
      
      if (counter) {
        if (currentImageGallery.length > 1) {
          counter.textContent = `${currentImageIndex + 1} / ${currentImageGallery.length}`;
          counter.style.display = 'block';
        } else {
          counter.style.display = 'none';
        }
      }
    }
    
    function closeImageOverlay() {
      document.getElementById('imageOverlay').classList.remove('show');
      currentImageGallery = [];
      currentImageIndex = 0;
    }
    
    document.getElementById('imageOverlay').addEventListener('click', (e) => {
      if (e.target.id === 'imageOverlay') closeImageOverlay();
    });
    
    document.addEventListener('keydown', (e) => { 
      if (e.key === 'Escape') {
        closeImageOverlay();
      } else if (e.key === 'ArrowRight') {
        if (currentImageGallery.length > 0) {
          e.preventDefault();
          nextImage();
        }
      } else if (e.key === 'ArrowLeft') {
        if (currentImageGallery.length > 0) {
          e.preventDefault();
          prevImage();
        }
      }
    });
    
    // Event listener for validation panel image thumbnails
    document.addEventListener('click', (e) => {
      console.log('Click detected on:', e.target, 'Classes:', e.target.classList);
      
      if (e.target.classList.contains('validation-image-thumb')) {
        console.log('Validation image thumb clicked!');
        
        const galleryId = e.target.getAttribute('data-gallery-id');
        const imageIndex = parseInt(e.target.getAttribute('data-image-index'));
        
        console.log('Gallery ID:', galleryId);
        console.log('Image index:', imageIndex);
        
        const galleryImages = imageGalleries[galleryId];
        
        if (galleryImages && galleryImages.length > 0) {
          console.log('Opening gallery with', galleryImages.length, 'images');
          openImageGallery(galleryImages, imageIndex);
        } else {
          console.error('Gallery not found:', galleryId);
          alert('Image gallery not found');
        }
      }
    });
    urlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') visitBtn.click(); });

    /* === LLM (compare) minimal hook === */
    (function(){
      const btn = document.getElementById('llmCompareBtn');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        const url = (document.getElementById('urlInput')?.value || '').trim();
        if (!url) { alert('Paste a URL first.'); return; }
        try {
          await window.api.openCompare?.(url);
        } catch (e) {
          alert('Compare window failed. Make sure main_bridge.js is required from main.js');
        }
      });
    })();
    // Mobile Preview Functions with Smart Quality Scoring
    function updateMobilePreview(imageUrls) {
      const mobileGrid = document.getElementById("mobileGrid");
      const imageCount = document.getElementById("imageCount");
      
      if (!imageUrls || imageUrls.length === 0) {
        mobileGrid.innerHTML = '<div style="text-align:center;color:#666;padding:40px;">No images to preview</div>';
        imageCount.textContent = "0 images";
        return;
      }
      
      // Preserve original order, only move clearly bad images to bottom
      const scoredImages = imageUrls.map((url, index) => ({
        url: url,
        score: calculateImageQualityScore(url),
        quality: getQualityLabel(calculateImageQualityScore(url)),
        originalIndex: index,
        isClearlyBad: isClearlyBadImage(url, calculateImageQualityScore(url))
      }));
      
      // Separate good images (keep original order) from clearly bad ones
      const goodImages = scoredImages.filter(img => !img.isClearlyBad);
      const badImages = scoredImages.filter(img => img.isClearlyBad);
      
      // Combine: good images in original order + bad images at bottom
      const orderedImages = [...goodImages, ...badImages];
      
      // Create Pinterest-style masonry grid
      mobileGrid.innerHTML = orderedImages.map((item, index) => `
        <div class="mobile-image-card" onclick="openMobileImageDetail('${item.url}', '${item.quality}')" data-index="${index}">
          <div class="quality-badge quality-${item.quality}">${item.quality.toUpperCase()}</div>
          <div class="mobile-tag-icon"></div>
          <img src="${item.url}" referrerpolicy="no-referrer" 
               onerror="this.parentElement.style.display='none'"
               onload="this.classList.add('loaded')">
        </div>
      `).join("");
      
      imageCount.textContent = `${imageUrls.length} images`;
      
      // Scroll to top when updating
      const mobileContainer = document.getElementById('mobileContainer');
      if (mobileContainer) mobileContainer.scrollTop = 0;
      
      // Reinitialize device toggle and mobile modal to ensure they work
      setTimeout(() => {
        initDeviceToggle();
        initMobileModal();
      }, 100);
    }
    
    // Image Quality Scoring Algorithm  
    function calculateImageQualityScore(url) {
      let score = 50; // Base score
      const urlLower = url.toLowerCase();
      
      // URL keyword analysis
      const productKeywords = ['product', 'gallery', 'zoom', 'large', 'detail', 'main', 'primary'];
      const bannerKeywords = ['banner', 'hero', 'promo', 'ad', 'advertisement', 'header', 'logo'];
      
      productKeywords.forEach(keyword => {
        if (urlLower.includes(keyword)) score += 15;
      });
      
      bannerKeywords.forEach(keyword => {
        if (urlLower.includes(keyword)) score -= 25;
      });
      
      // Size estimation from URL patterns (common CDN patterns)
      const sizeMatch = url.match(/[\/_](\d{3,4})[x\/_]?(\d{3,4})?/);
      if (sizeMatch) {
        const width = parseInt(sizeMatch[1]);
        const height = parseInt(sizeMatch[2]) || width;
        
        // Size scoring
        if (width >= 400 && height >= 400) score += 20;
        else if (width >= 300 || height >= 300) score += 10;
        else if (width < 200 && height < 200) score -= 15;
        
        // Aspect ratio scoring  
        const aspectRatio = width / height;
        if (aspectRatio >= 0.8 && aspectRatio <= 1.25) {
          score += 20; // Square/near-square (ideal product shots)
        } else if (aspectRatio >= 2.0) {
          score -= 30; // Wide banners
        } else if (aspectRatio >= 3.0) {
          score -= 50; // Very wide banners
        }
      }
      
      // File type preferences
      if (urlLower.includes('.webp') || urlLower.includes('.jpg')) score += 5;
      if (urlLower.includes('.gif')) score -= 10; // Often low quality
      
      return Math.max(0, Math.min(100, score)); // Clamp 0-100
    }
    
    function getQualityLabel(score) {
      if (score >= 70) return 'high';
      if (score >= 40) return 'medium'; 
      return 'low';
    }
    
    // Identify clearly bad images that should move to bottom
    function isClearlyBadImage(url, score) {
      const urlLower = url.toLowerCase();
      
      // Strong banner indicators
      const bannerKeywords = ['banner', 'hero', 'promo', 'ad', 'advertisement', 'header'];
      const hasBannerKeyword = bannerKeywords.some(keyword => urlLower.includes(keyword));
      
      // Size analysis from URL patterns
      const sizeMatch = url.match(/[\/_](\d{3,4})[x\/_]?(\d{3,4})?/);
      let isTooSmall = false;
      let isWideBanner = false;
      
      if (sizeMatch) {
        const width = parseInt(sizeMatch[1]);
        const height = parseInt(sizeMatch[2]) || width;
        const aspectRatio = width / height;
        
        isTooSmall = width < 300 && height < 300; // Both dimensions small
        isWideBanner = aspectRatio >= 2.5; // Very wide banners
      }
      
      // Only move clearly problematic images
      return hasBannerKeyword || isTooSmall || isWideBanner || score < 25;
    }
    
    // Initialize device toggle functionality  
    function initDeviceToggle() {
      const iphoneBtn = document.getElementById("iphoneBtn");
      const ipadBtn = document.getElementById("ipadBtn");
      const mobileContainer = document.getElementById("mobileContainer");
      
      if (iphoneBtn && ipadBtn && mobileContainer) {
        // Remove any existing listeners
        iphoneBtn.onclick = null;
        ipadBtn.onclick = null;
        
        iphoneBtn.onclick = () => {
          console.log('iPhone clicked');
          mobileContainer.className = "mobile-container iphone";
          iphoneBtn.className = "device-btn active";
          ipadBtn.className = "device-btn";
          iphoneBtn.style.background = "#2196F3";
          iphoneBtn.style.color = "white";
          ipadBtn.style.background = "#ccc";
          ipadBtn.style.color = "#333";
          mobileContainer.scrollTop = 0;
        };
        
        ipadBtn.onclick = () => {
          console.log('iPad clicked - switching to 3 columns');
          mobileContainer.className = "mobile-container ipad";
          ipadBtn.className = "device-btn active";
          iphoneBtn.className = "device-btn";
          ipadBtn.style.background = "#2196F3";
          ipadBtn.style.color = "white";
          iphoneBtn.style.background = "#ccc";
          iphoneBtn.style.color = "#333";
          mobileContainer.scrollTop = 0;
        };
      }
    }
    
    // Initialize on DOM ready and after mobile preview updates
    document.addEventListener("DOMContentLoaded", initDeviceToggle);
    
    // Mobile Image Detail Modal Functions (Pinterest-style)
    function openMobileImageDetail(imageUrl, quality) {
      console.log('Opening mobile image detail:', imageUrl);
      
      const modal = document.getElementById('mobileImageModal');
      const modalImage = document.getElementById('mobileModalImage');
      const qualityIndicator = document.getElementById('mobileImageQuality');
      const imageUrlDisplay = document.getElementById('mobileImageUrl');
      
      if (modal && modalImage) {
        modalImage.src = imageUrl;
        qualityIndicator.textContent = quality.toUpperCase();
        qualityIndicator.className = `mobile-quality-indicator ${quality}`;
        imageUrlDisplay.textContent = imageUrl.length > 50 ? imageUrl.substring(0, 50) + '...' : imageUrl;
        
        modal.classList.add('show');
        
        // Scroll mobile container to top
        const mobileContainer = document.getElementById('mobileContainer');
        if (mobileContainer) mobileContainer.scrollTop = 0;
      }
    }
    
    function closeMobileImageDetail() {
      console.log('Closing mobile image detail');
      const modal = document.getElementById('mobileImageModal');
      if (modal) {
        modal.classList.remove('show');
      }
    }
    
    // Initialize mobile modal controls
    function initMobileModal() {
      const backBtn = document.getElementById('mobileBackBtn');
      const saveBtn = document.getElementById('mobileSaveBtn');
      
      if (backBtn) {
        backBtn.onclick = closeMobileImageDetail;
      }
      
      if (saveBtn) {
        saveBtn.onclick = () => {
          console.log('Save clicked in mobile modal');
          // Could implement save functionality here
          closeMobileImageDetail();
        };
      }
    }
    
    // Initialize mobile modal on DOM ready
    document.addEventListener("DOMContentLoaded", initMobileModal);


    // Validation Panel Functions
    function showValidationPanel(results, summaryMsg, foundSuggestions) {
      const panel = document.getElementById('validationPanel');
      const content = document.getElementById('validationContent');
      
      // Clear previous content
      content.innerHTML = '';
      
      // Add summary header
      const summary = document.createElement('div');
      summary.style.cssText = 'background: #f0f7ff; border: 1px solid #b3d7ff; border-radius: 4px; padding: 10px; margin-bottom: 16px; font-size: 13px;';
      summary.innerHTML = `<strong>Summary:</strong> ${summaryMsg}<br><strong>Found:</strong> ${foundSuggestions} fields with suggestions`;
      content.appendChild(summary);
      
      // Generate field cards
      const fields = ['title', 'price', 'images', 'brand', 'tags', 'description'];
      
      for (const field of fields) {
        const result = results ? results[field] : null;
        const card = createFieldCard(field, result);
        content.appendChild(card);
      }
      
      // Show panel
      panel.style.display = 'block';
    }
    
    function createFieldCard(field, result) {
      const card = document.createElement('div');
      card.className = 'field-card';
      
      const isSuccess = result && result.ok && result.selectors && result.selectors.length > 0;
      const statusClass = isSuccess ? 'success' : 'failed';
      const statusText = isSuccess ? 'Found' : 'Not Found';
      
      let previewContent = '';
      let selectorText = '';
      
      if (isSuccess) {
        const topResult = result.testedSelectors && result.testedSelectors[0];
        if (topResult) {
          selectorText = topResult.selector;
          
          if (field === 'images' && Array.isArray(topResult.validatedValue)) {
            previewContent = `
              <div class="field-preview"><strong>Found ${topResult.validatedValue.length} images:</strong></div>
              <div class="image-thumbnails" style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; max-height: 120px; overflow-y: auto;">
                ${topResult.validatedValue.slice(0, 10).map((url, index) => 
                  `<img src="${url}" alt="Product image ${index + 1}" 
                       style="width: 48px; height: 48px; object-fit: cover; border-radius: 4px; border: 1px solid #ddd; cursor: pointer;" 
                       data-gallery-images='${JSON.stringify(topResult.validatedValue)}' 
                       data-image-index="${index}"
                       class="validation-image-thumb"
                       onerror="this.style.display='none'" />`
                ).join('')}
                ${topResult.validatedValue.length > 10 ? `<div style="font-size: 10px; color: #666; margin-top: 4px;">... and ${topResult.validatedValue.length - 10} more</div>` : ''}
              </div>
            `;
          } else if (topResult.validatedValue) {
            const value = String(topResult.validatedValue);
            const truncated = value.length > 80 ? value.substring(0, 80) + '...' : value;
            previewContent = `<div class="field-preview"><strong>Value:</strong> ${truncated}</div>`;
          }
        }
      } else {
        const reason = result && result.error ? result.error : 'No valid selectors found';
        previewContent = `<div class="field-preview" style="color: #666;">Reason: ${reason}</div>`;
      }
      
      card.innerHTML = `
        <div class="field-header">
          <span>${field.charAt(0).toUpperCase() + field.slice(1)}</span>
          <span class="field-status ${statusClass}">${statusText}</span>
        </div>
        <div class="field-body">
          ${previewContent}
          ${selectorText ? `<div class="field-selector">Selector: ${selectorText}</div>` : ''}
          ${isSuccess ? `<label style="margin-top: 8px; display: block;"><input type="checkbox" class="field-apply-checkbox" data-field="${field}" checked> Apply this field</label>` : ''}
        </div>
      `;
      
      return card;
    }
    
    function hideValidationPanel() {
      document.getElementById('validationPanel').style.display = 'none';
    }
    
    async function applyAllValidated() {
      const checkboxes = document.querySelectorAll('.field-apply-checkbox:checked');
      let appliedCount = 0;
      
      for (const checkbox of checkboxes) {
        const field = checkbox.getAttribute('data-field');
        // Apply the field (this would trigger the same logic as clicking "Use AI Suggestion")
        // For now, just mark the checkbox as OK
        const okCheckbox = document.getElementById(`ok${field.charAt(0).toUpperCase() + field.slice(1)}`);
        if (okCheckbox) {
          okCheckbox.checked = true;
          appliedCount++;
        }
      }
      
      hideValidationPanel();
      
      if (appliedCount > 0) {
        alert(`‚úÖ Applied ${appliedCount} fields successfully!\n\nThe selectors have been marked as validated. Use "Save (scrape)" to save them to memory.`);
        
        // Auto-validate to refresh the UI
        await autoValidateIfNeeded();
      }
    }
  </script>

  <!-- Image Overlay Modal -->
  <div id="imageOverlay" class="image-overlay">
    <div class="overlay-content">
      <button class="close-overlay" onclick="closeImageOverlay()">&times;</button>
      <img id="overlayImage" class="overlay-image" src="" alt="Full size image">
    </div>
  </div>

  <!-- Validation Panel -->
  <div class="validation-panel" id="validationPanel">
    <div class="validation-header">
      <span>ü§ñ Batch AI Results - Review & Apply</span>
      <button onclick="hideValidationPanel()" style="background: none; border: none; font-size: 18px; cursor: pointer;">&times;</button>
    </div>
    <div class="validation-content" id="validationContent">
      <!-- Field cards will be dynamically generated here -->
    </div>
    <div class="validation-footer">
      <button onclick="applyAllValidated()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Apply All Selected</button>
      <button onclick="hideValidationPanel()" style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Cancel</button>
    </div>
  </div>
  <!-- Load diagnostics functionality -->
  <script src="diagnostics.js"></script>
</body>
</html>
