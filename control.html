<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tagglo Control</title>
  <style>
    body { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; color:#111; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
    input[type="text"] { width: 560px; padding:8px 10px; border:1px solid #ccc; border-radius:6px; }
    button { padding:8px 12px; border:0; border-radius:6px; background:#111; color:#fff; cursor:pointer; }
    button[disabled] { opacity:.5; cursor:not-allowed; }
    #out { white-space: pre; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:8px; margin-top:12px; max-height: 44vh; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .pill { display:inline-block; background:#eee; border-radius:999px; padding:2px 8px; margin-right:6px; font-size:12px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .box { border:1px solid #eee; border-radius:8px; padding:10px; background:#fff; }
    .label { font-weight:700; margin-bottom:4px; }
    .imgs { display:flex; gap:6px; flex-wrap:wrap; }
    .imgs img { height:64px; border-radius:6px; border:1px solid #eee; cursor:pointer; transition:transform 0.2s; }
    .imgs img:hover { transform:scale(1.05); }
    
    /* Image Overlay Modal */
    .image-overlay { 
      position:fixed; top:0; left:0; width:100%; height:100%; 
      background:rgba(0,0,0,0.9); display:none; z-index:1000; 
      justify-content:center; align-items:center; 
    }
    .image-overlay.show { display:flex; }
    .overlay-content { 
      position:relative; max-width:90%; max-height:90%; 
      display:flex; justify-content:center; align-items:center; 
    }
    .overlay-image { 
      max-width:100%; max-height:100%; object-fit:contain; 
      border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.5); 
    }
    .close-overlay { 
      position:absolute; top:-40px; right:0; background:none; 
      border:none; color:white; font-size:24px; cursor:pointer; 
      padding:8px; border-radius:4px; 
    }
    .close-overlay:hover { background:rgba(255,255,255,0.2); }
  </style>
</head>
<body>
  <div class="row">
    <input id="urlInput" type="text" placeholder="Paste product URL" />
    <button id="visitBtn">Load</button>
    <button id="nudgeBtn">Nudge</button>
    <button id="saveBtn" disabled>Save (scrape)</button>
  </div>

  <div id="status"></div>

  <div id="panel" class="grid" style="display:none; margin-top:12px;">
    <div class="box">
      <div class="label">Scrape Result</div>
      <div id="summary"></div>
      <div id="images" class="imgs" style="margin-top:6px;"></div>
    </div>
    <div class="box">
      <div class="label">Selector Memory (approve to save)</div>
      <div>
        <label><input type="checkbox" id="okTitle"> Title OK</label>
        <label style="margin-left:12px;"><input type="checkbox" id="okPrice"> Price OK</label>
        <label style="margin-left:12px;"><input type="checkbox" id="okImages"> Images OK</label>
        <br>
        <label><input type="checkbox" id="okBrand"> Brand OK</label>
        <label style="margin-left:12px;"><input type="checkbox" id="okTags"> Tags OK</label>
        <label style="margin-left:12px;"><input type="checkbox" id="okDesc"> Description OK</label>
      </div>
      <div id="memDebug" style="margin-top:8px; font-size:12px; opacity:.8;"></div>
      <div style="margin-top:8px;">
        <button id="saveMemBtn">Save selectors for this host</button>
        <button id="clearMemBtn" style="background:#b22;">Clear memory (host)</button>
      </div>
    </div>
  </div>

  <div class="label" style="margin-top:10px;">Image URLs (top 20)</div>
  <div id="out" title="Only image URLs appear here"></div>

  <script>
    const urlInput = document.getElementById('urlInput');
    const visitBtn = document.getElementById('visitBtn');
    const nudgeBtn = document.getElementById('nudgeBtn');
    const saveBtn  = document.getElementById('saveBtn');
    const statusEl = document.getElementById('status');

    const panel = document.getElementById('panel');
    const summary = document.getElementById('summary');
    const images = document.getElementById('images');
    const out = document.getElementById('out');

    const okTitle = document.getElementById('okTitle');
    const okPrice = document.getElementById('okPrice');
    const okImages = document.getElementById('okImages');
    const okBrand = document.getElementById('okBrand');
    const okTags  = document.getElementById('okTags');
    const okDesc  = document.getElementById('okDesc');
    const saveMemBtn = document.getElementById('saveMemBtn');
    const clearMemBtn = document.getElementById('clearMemBtn');
    const memDebug = document.getElementById('memDebug');

    let currentHost = null;
    let lastSelectorsUsed = null;
    let lastPayload = null;

    function setSaveState(disabled, label) {
      saveBtn.disabled = disabled;
      saveBtn.textContent = label || (disabled ? 'Waiting for pageâ€¦' : 'Save (scrape)');
    }

    function hostFrom(url) {
      try { return new URL(url).host.replace(/^www\./,''); } catch { return null; }
    }

    // Load (navigate only)
    visitBtn.onclick = async () => {
      const url = urlInput.value.trim();
      if (!url) return;
      currentHost = hostFrom(url);
      panel.style.display = 'none';
      out.textContent = '';
      images.innerHTML = '';
      summary.innerHTML = '';
      statusEl.innerHTML = `<span class="pill">Loading ${currentHost}</span>`;
      await window.api.openProduct(url);

      // poll readiness and enable Save once likely hydrated
      setSaveState(true, 'Waiting for pageâ€¦');
      const iv = setInterval(async () => {
        const ok = await window.api.evalInProduct(`
          (async () => {
            const h1 = document.querySelector("h1,[itemprop='name']");
            const price = document.querySelector("[itemprop='price'],[data-price],[class*='price'] .money");
            const imgs = document.querySelector("img[src], picture source[srcset], [data-zoom-image], [data-large-image]");
            return !!(h1 && (price || imgs));
          })();
        `);
        if (ok) {
          clearInterval(iv);
          statusEl.innerHTML = `<span class="pill">Ready</span>`;
          setSaveState(false);
        }
      }, 700);
    };

    // â€œNudgeâ€ to hydrate galleries/lazy content
    nudgeBtn.onclick = async () => {
      await window.api.evalInProduct(`
        (async () => {
          function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
          window.scrollTo(0,0); await sleep(90);
          window.scrollTo(0, document.body.scrollHeight); await sleep(180);
          document.querySelectorAll('.swiper-slide, .slick-slide, .glide__slide, .splide__slide')
            .forEach((s,i)=>{ if (i<8) s.dispatchEvent(new Event('mouseover',{bubbles:true})); });
        })();
      `);
    };

    // Save (scrape)
    saveBtn.onclick = async () => {
      setSaveState(true, 'Scrapingâ€¦');
      statusEl.innerHTML = `<span class="pill">Scraping</span>`;
      panel.style.display = 'none';
      out.textContent = '';
      images.innerHTML = '';
      summary.innerHTML = '';
      okTitle.checked = okPrice.checked = okImages.checked = okBrand.checked = okTags.checked = okDesc.checked = false;
      memDebug.textContent = '';

      try {
        const { result, selectorsUsed } = await window.api.scrapeCurrent();
        lastPayload = result || {};
        lastSelectorsUsed = selectorsUsed || null;

        // summary (top panel)
        const imgs = Array.isArray(result?.images) ? result.images : [];
        summary.innerHTML = `
          <div><b>Title:</b> ${result?.title || ''}</div>
          <div><b>Price:</b> ${result?.price || ''}</div>
          <div><b>Brand:</b> ${result?.brand || ''}</div>
          <div><b>URL:</b> ${result?.url || ''}</div>
          <div style="margin-top:4px;"><b>Specs:</b> ${(result?.specs||[]).slice(0,20).join(' Â· ')}</div>
          <div><b>Tags:</b> ${(result?.tags||[]).slice(0,12).join(' Â· ')}</div>
          <div><b>Description:</b> ${(result?.description || '').slice(0,240)}</div>
        `;
        images.innerHTML = imgs.map(u => `<img src="${u}" title="${u}" onclick="openImageOverlay('${u}')">`).join('');

        // bottom box = ONLY image URLs (one per line)
        out.textContent = imgs.join('\n');

        // show panel + current memory
        const mem = currentHost ? await window.api.getSelectorMemory(currentHost) : null;
        
        // Clean memory display - show user-friendly summary
        if (mem && Object.keys(mem).filter(k => k !== '__history').length > 0) {
          const savedFields = Object.keys(mem).filter(k => k !== '__history');
          const lastUpdate = mem.__history && mem.__history.length > 0 
            ? new Date(mem.__history[mem.__history.length - 1].savedAt).toLocaleDateString()
            : 'Unknown';
          memDebug.innerHTML = `
            <div style="color: #2d5a27; font-weight: bold;">âœ“ Saved selectors for ${savedFields.length} field(s)</div>
            <div style="font-size: 11px; opacity: 0.8;">Fields: ${savedFields.join(', ')}</div>
            <div style="font-size: 11px; opacity: 0.8;">Last updated: ${lastUpdate}</div>
          `;
        } else {
          memDebug.innerHTML = '<div style="color: #666;">No saved selectors for this domain</div>';
        }

        // Load existing memory state into checkboxes
        if (mem) {
          okTitle.checked = !!mem.title;
          okPrice.checked = !!mem.price;
          okImages.checked = !!mem.images;
          okBrand.checked = !!mem.brand;
          okTags.checked = !!mem.tags;
          okDesc.checked = !!mem.description;
        }

        panel.style.display = 'grid';
        statusEl.innerHTML = `<span class="pill">Done</span>`;
      } catch (e) {
        out.textContent = 'Error: ' + (e?.message || String(e));
        statusEl.innerHTML = `<span class="pill" style="background:#fdd; color:#900;">Error</span>`;
      } finally {
        setSaveState(false);
      }
    };

    // Save selectors to memory (only for checked fields) - reverse engineer from validated content
    saveMemBtn.onclick = async () => {
      if (!currentHost || !lastPayload) return;
      
      const fields = {};
      
      // Helper function to reverse-engineer selectors for text content
      async function findSelectorsForText(content, fieldType) {
        if (!content || typeof content !== 'string') return null;
        
        const searchScript = `
          (function() {
            const content = ${JSON.stringify(content)};
            const results = [];
            
            // Smart text matching based on field type
            const fieldType = ${JSON.stringify(fieldType)};
            const matchingElements = [];
            
            // For different field types, use different matching strategies
            if (fieldType === 'brand') {
              // Brand: look in specific brand containers first
              const brandSelectors = [
                '[itemprop="brand"]', '.brand', '.product-brand', 
                '[data-brand]', '.manufacturer', '.vendor'
              ];
              for (const sel of brandSelectors) {
                const el = document.querySelector(sel);
                if (el && el.textContent.trim().includes(content)) {
                  matchingElements.push(el);
                }
              }
            }
            
            if (fieldType === 'description') {
              // Description: look in description containers
              const descSelectors = [
                '[itemprop="description"]', '.description', '.product-description',
                '.product-details', '.product-info', '.product-summary'
              ];
              for (const sel of descSelectors) {
                const el = document.querySelector(sel);
                if (el && el.textContent.trim().includes(content.substring(0, 50))) {
                  matchingElements.push(el);
                }
              }
            }
            
            // General text walker for all fields (fallback + title/price)
            const walker = document.createTreeWalker(
              document.body, 
              NodeFilter.SHOW_TEXT, 
              null, 
              false
            );
            
            let node;
            while (node = walker.nextNode()) {
              const text = node.textContent.trim();
              const parent = node.parentElement;
              
              // Skip if already found via specific selectors
              if (matchingElements.includes(parent)) continue;
              
              // Exact match
              if (text === content) {
                matchingElements.push(parent);
              }
              // Partial match for longer content (descriptions, etc)
              else if (content.length > 15 && text.length > 15 && text.includes(content)) {
                matchingElements.push(parent);
              }
              // For shorter content, check if text contains our content as a word
              else if (content.length <= 15 && text.length > 5) {
                const words = text.toLowerCase().split(/\\s+/);
                const contentWords = content.toLowerCase().split(/\\s+/);
                if (contentWords.every(w => words.includes(w))) {
                  matchingElements.push(parent);
                }
              }
            }
            
            // Generate CSS selectors for matching elements
            function generateSelector(el) {
              if (!el || el === document.body) return null;
              
              // Prefer ID
              if (el.id) return '#' + el.id;
              
              // Try specific classes
              if (el.className) {
                const classes = el.className.split(' ').filter(c => c && 
                  /^(product|title|price|name|brand|desc)/i.test(c));
                if (classes.length) return '.' + classes.join('.');
              }
              
              // Try attribute-based selectors
              for (const attr of ['itemprop', 'data-product', 'data-price', 'data-title']) {
                if (el.hasAttribute(attr)) return '[' + attr + '="' + el.getAttribute(attr) + '"]';
              }
              
              // Fallback to tag + classes
              const tag = el.tagName.toLowerCase();
              if (el.className) {
                const mainClass = el.className.split(' ')[0];
                if (mainClass) return tag + '.' + mainClass;
              }
              
              return tag;
            }
            
            const selectors = [];
            for (const el of matchingElements.slice(0, 3)) { // Limit to 3 best matches
              const sel = generateSelector(el);
              if (sel && !selectors.includes(sel)) {
                selectors.push(sel);
              }
            }
            
            return selectors.length ? { selectors, attr: 'text' } : null;
          })();
        `;
        
        try {
          return await window.api.evalInProduct(searchScript);
        } catch (e) {
          console.error('Error finding selectors for', fieldType, ':', e);
          return null;
        }
      }
      
      // Helper function to find image selectors (improved)
      async function findSelectorsForImages(imageUrls) {
        if (!Array.isArray(imageUrls) || !imageUrls.length) return null;
        
        const searchScript = `
          (function() {
            const imageUrls = ${JSON.stringify(imageUrls.slice(0, 5))}; // Check first 5 images
            const selectors = new Set();
            
            // First try to find product image containers
            const containers = [
              '.product-images, .product-gallery, .gallery',
              '[data-gallery], [data-images], .image-gallery',
              '.product-media, .product-photos, .photos',
              '.carousel, .slider, .swiper-wrapper',
              '.product-image-container, .main-image'
            ];
            
            for (const containerSel of containers) {
              const container = document.querySelector(containerSel);
              if (container) {
                const imgs = container.querySelectorAll('img');
                if (imgs.length >= 2) { // Must have multiple images
                  selectors.add(containerSel + ' img');
                  break;
                }
              }
            }
            
            // If no container found, match individual images
            if (selectors.size === 0) {
              for (const url of imageUrls) {
                const imgs = document.querySelectorAll('img');
                for (const img of imgs) {
                  if (img.src === url || img.currentSrc === url) {
                    // Generate selector for this image
                    if (img.id) selectors.add('#' + img.id);
                    else if (img.className) {
                      const classes = img.className.split(' ').filter(c => c);
                      if (classes.length) selectors.add('img.' + classes.join('.'));
                    }
                    else selectors.add('img[src*="' + url.split('/').pop().split('?')[0] + '"]');
                    break;
                  }
                }
              }
            }
            
            console.log('[DEBUG] Image selector search results:', {
              containersChecked: ${JSON.stringify(['`.product-images, .product-gallery, .gallery`', '`[data-gallery], [data-images], .image-gallery`', '`.product-media, .product-photos, .photos`', '`.carousel, .slider, .swiper-wrapper`', '`.product-image-container, .main-image`'])},
              selectorsFound: Array.from(selectors),
              totalImages: document.querySelectorAll('img').length
            });
            
            return selectors.size ? { selectors: Array.from(selectors), attr: 'src' } : null;
          })();
        `;
        
        try {
          return await window.api.evalInProduct(searchScript);
        } catch (e) {
          console.error('Error finding image selectors:', e);
          return null;
        }
      }
      
      // Get current memory to determine what to add/remove
      const currentMem = await window.api.getSelectorMemory(currentHost) || {};
      const fieldsToRemove = [];
      
      // Check each field: add if checked and has data, remove if unchecked but exists in memory
      const fieldChecks = [
        { field: 'title', checked: okTitle.checked, data: lastPayload.title },
        { field: 'price', checked: okPrice.checked, data: lastPayload.price },
        { field: 'brand', checked: okBrand.checked, data: lastPayload.brand },
        { field: 'description', checked: okDesc.checked, data: lastPayload.description },
        { field: 'images', checked: okImages.checked, data: lastPayload.images },
        { field: 'tags', checked: okTags.checked, data: lastPayload.tags }
      ];
      
      // Debug: Log available data
      console.log('[DEBUG] Available data in lastPayload:', {
        title: lastPayload.title,
        price: lastPayload.price,
        brand: lastPayload.brand,
        description: lastPayload.description ? lastPayload.description.substring(0, 100) + '...' : null,
        images: lastPayload.images ? `${lastPayload.images.length} images` : null,
        tags: lastPayload.tags ? `${lastPayload.tags.length} tags: ${lastPayload.tags.slice(0, 3).join(', ')}` : null
      });

      // Process each field with detailed logging
      for (const { field, checked, data } of fieldChecks) {
        console.log(`[DEBUG] Processing field "${field}": checked=${checked}, hasData=${!!data}`);
        
        if (checked && data) {
          // Add/update field
          let result = null;
          
          if (field === 'images') {
            console.log(`[DEBUG] Finding selectors for ${data.length} images`);
            result = await findSelectorsForImages(data);
          } else if (field === 'tags' && Array.isArray(data) && data.length) {
            const tagsText = data.slice(0, 3).join(' '); // Use first few tags
            console.log(`[DEBUG] Finding selectors for tags: "${tagsText}"`);
            result = await findSelectorsForText(tagsText, field);
          } else if (typeof data === 'string' && data.trim()) {
            console.log(`[DEBUG] Finding selectors for ${field}: "${data.substring(0, 50)}..."`);
            result = await findSelectorsForText(data, field);
          } else {
            console.log(`[DEBUG] Skipping ${field}: invalid data type or empty`, typeof data, data);
          }
          
          if (result) {
            // Add logic type tracking
            result.logicType = 'reverse-engineered'; // Mark as reverse-engineered from user validation
            result.savedAt = new Date().toISOString();
            fields[field] = result;
            console.log(`[DEBUG] Found selectors for ${field}:`, result.selectors);
          } else {
            console.log(`[DEBUG] No selectors found for ${field}`);
          }
        } else if (!checked && currentMem[field]) {
          // Remove field if unchecked but exists in memory
          fieldsToRemove.push(field);
          console.log(`[DEBUG] Marking ${field} for removal`);
        }
      }
      
      // Handle removals first
      if (fieldsToRemove.length > 0) {
        await window.api.clearSelectorMemory(currentHost, fieldsToRemove);
      }
      
      // Handle additions/updates
      if (Object.keys(fields).length > 0) {
        const note = `Updated from user validation on ${new Date().toLocaleDateString()}`;
        await window.api.setSelectorMemory(currentHost, fields, note);
      }
      
      // Show detailed result message
      const addedFields = Object.keys(fields);
      const failedFields = fieldChecks
        .filter(({ field, checked, data }) => checked && data && !fields[field])
        .map(({ field }) => field);
      
      const messages = [];
      if (addedFields.length > 0) messages.push(`âœ… Saved: ${addedFields.join(', ')}`);
      if (fieldsToRemove.length > 0) messages.push(`ðŸ—‘ï¸ Removed: ${fieldsToRemove.join(', ')}`);
      if (failedFields.length > 0) messages.push(`âŒ Failed to find selectors: ${failedFields.join(', ')}`);
      
      if (messages.length === 0) {
        alert('No changes made. Check fields with valid data to save selectors.\n\nTip: Check the browser console (F12) for debug information.');
        return;
      }
      
      // Update display with new clean format
      const mem = await window.api.getSelectorMemory(currentHost);
      if (mem && Object.keys(mem).filter(k => k !== '__history').length > 0) {
        const savedFields = Object.keys(mem).filter(k => k !== '__history');
        const lastUpdate = mem.__history && mem.__history.length > 0 
          ? new Date(mem.__history[mem.__history.length - 1].savedAt).toLocaleDateString()
          : 'Unknown';
        memDebug.innerHTML = `
          <div style="color: #2d5a27; font-weight: bold;">âœ“ Saved selectors for ${savedFields.length} field(s)</div>
          <div style="font-size: 11px; opacity: 0.8;">Fields: ${savedFields.join(', ')}</div>
          <div style="font-size: 11px; opacity: 0.8;">Last updated: ${lastUpdate}</div>
        `;
      } else {
        memDebug.innerHTML = '<div style="color: #666;">No saved selectors for this domain</div>';
      }
      
      alert(messages.join('\n'));
    };

    clearMemBtn.onclick = async () => {
      if (!currentHost) return;
      const confirmed = confirm('Are you sure you want to clear all saved selectors for this domain?');
      if (!confirmed) return;
      
      await window.api.clearSelectorMemory(currentHost);
      
      // Update display with clean format
      memDebug.innerHTML = '<div style="color: #666;">No saved selectors for this domain</div>';
      
      // Reset all checkboxes
      okTitle.checked = okPrice.checked = okImages.checked = okBrand.checked = okTags.checked = okDesc.checked = false;
      
      alert('All selectors cleared for this domain.');
    };

    // Image overlay functions
    function openImageOverlay(imageUrl) {
      const overlay = document.getElementById('imageOverlay');
      const overlayImage = document.getElementById('overlayImage');
      overlayImage.src = imageUrl;
      overlay.classList.add('show');
    }

    function closeImageOverlay() {
      const overlay = document.getElementById('imageOverlay');
      overlay.classList.remove('show');
    }

    // Click outside image to close overlay
    document.getElementById('imageOverlay').addEventListener('click', (e) => {
      if (e.target.id === 'imageOverlay') {
        closeImageOverlay();
      }
    });

    // Escape key to close overlay
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeImageOverlay();
      }
    });

    // conveniences
    urlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') visitBtn.click(); });
  </script>

  <!-- Image Overlay Modal -->
  <div id="imageOverlay" class="image-overlay">
    <div class="overlay-content">
      <button class="close-overlay" onclick="closeImageOverlay()">&times;</button>
      <img id="overlayImage" class="overlay-image" src="" alt="Full size image">
    </div>
  </div>

</body>
</html>
